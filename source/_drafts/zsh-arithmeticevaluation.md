---
title: Zsh算数求值
tags:
---
<!-- toc -->
# 算数求值
 1. shell可以进行整数和浮点数的算数运算， 可以使用let, 或者`$(( expr ))`.
 2. 如果可能的话Zsh将使用8字节的整数，有关这一点，你可以测试一下:
```zsh
$ print - $(( 12345678901 ))
1234567890
# 如果数字没有发生变化，则说明整数精度()至少为8字节
```
 3. 浮点类型为双精度(double)

## let <ArithmeticExpressions>
内置的let命令可以处理算数表达式(ArithmeticExpressions).
```zsh
$ let x=1984
$ let y=x+1
$ print x=$x y=$y
1984 1985
$ let x=undefine
$ print $?
1
```
let的返回状态:
 * 如果表达式求值非0, 返回状态为0
 * 如果表达式求职为0, 返回状态为1
 * 无法求值， 返回状态为1
```zsh
# 除零错误
$ let x=0   ; print $?
0
$ let x=8   ; print $?
1
$ let x=1/0 ; print $?
zsh: division by zero
1
```
## (( expr1, expr2, ..., exprN ))
因为算数表达式比较常用，漫天飞let既不便于书写更不便于阅读维护.所以真正实用的还是这种小清新的书写方式。
因此`let expr`等价于`(( expr ))`:
```zsh
$ let x=1+1   ; print $x
2
$ (( x=1+1 )) ; print $x
2
```
`'(())'`中可以指定多个用`','`进行分割的算数表达式， 其最终值为`最后一个表达式`的值:
```
$ print $(( x=1, y=2, z=3))
3
```
## $[ expr1, expr2, ... exprN ] 和 $(( expr1, expr2, ... exprN ))
这两种方法都可以对表达式求值。
```zsh
$ echo $[n=1,m=10,m-n]
9
# 这与$(())是等价的
$ echo $((n=1,m=10,m-n))
9
# 但是，(())可以这么用
$ n=2;m=2
$ (( x=n+m )) ; echo $x
$ 4
# []就不行
$ [1+2]
zsh: no matches found: [1+2]
```
> 注意: 在算数表达式中出现的变量不需要使用`'$'`引用其值. 

```zsh
$ x=100
$ print $(( x+1 ))
1001
# 当然如果你加上'$'也不会有什么问题
$ print $(( $x+1 ))
1001
```

## 进制: <base>#number
通常来讲，zsh中出现在算数表达式中的数字都是十进制，因为人类习惯使然。 如果你想使用非十进制的表示方法，可以采用:

同样是11,在不同进制下的表示方法是不同的:
 * 十六进制: 16#0B  （也可以写作: 0x0B） 
 * 十进制:   10#11
 * 三进制:    3#102
 * 二进制:    2#1011

可以使用`[#base]`按照指定的进制打印数字。输出的形式同上:`base#number`, 另外浮点数输出不会受影响。

```zsh
$ print $(( [#16]11 ))
16#B
$ print $(( [#2]11 ))
2#1011
```

## typeset -i [base] var 
可以使用typset定义整形变量
 1. 如果使用字符串/字母给整型变量赋值， 赋值后为0
 2. 如果使用浮点数给整型变量赋值，浮点部分会被舍去

```zsh
$ typeset -i m n
$ m=1984 ; print $m
1984
$ m="no" ; print $m
0
$ m=3.14 ; print $m
3
```
 	
可以在定义整型变量时指定进制, 此后当输出该数的时候将使用`base#number`这种形式.
```zsh
$ typeset -i 16 x
$ x=11 ; print $x
16#B
# 当然，你可以使用[#base]改变输出形式
$ print $(( [#2] x ))
2#1011
```
## C_BASES
C_BASES选项可以指定使用标准的C语言中的十六进制表示方法。
  * 十六进制: 0xFF (而非: 16#FF)

## OCTAL_ZEROES
同上, OCTAL_ZEROES将采用C语言中的八进制表示方法。
  * 八进制: 077 (而非: 8#77)

## 不打印进制信息: [##base]
如果不要输出进制信息，可以采用双'#'表示法.
```zsh
$ print $(( [#2]  11 ))
2#1011
$ print $(( [##2] 11 ))
1011
```
## 算数运算符
| 操作符号 | 功能 |
|----|-----|
| +  |     |
| -  |     |
| *  |     |
| /  |     |
| %  | 取整 |
| ** | 阶乘 |
| ++ | 自增 |
| -- | 自减 |
## 位运算
| 操作符号 | 功能 |
|-------|-------|
| <<  | LSHIFT
| >>  | RSHIFT
| &   | AND
| ^   | XOR
| \&#124;  | OR
| !   | NOT

## 关系运算
| 操作符号 |
|-------|
| >  |
| <  | 
| >= |
| <= |
| == |
| != |

## 逻辑运算
| 操作符号 | 功能 |
|-|-|
| &&    | 逻辑AND |
| !&#124;   | 逻辑OR  |
| !^!^  | 逻辑XOR |

## 三元操作符: <expr> ? <expr> : <expr>
```zsh
$ x=4
$ print $(( x % 2 == 0 ? 2 : 1))
2
$ x=5
1
```

## 赋值
| 操作符号 |
|-------|
| +=    |
| -=    |
| *=    |
| /=    |
| %=    |
| &=    |
| &#124;=   |
| <<=   |
| >>=   |
| &&=   |
| !&#124;=  |
| !^!^= |
| !**=  |

## 浮点数
有关浮点数，需要强调一下输出格式，请看下面的例子:
```zsh
$ float PI=3.141592653
$ print ${PI}
3.141592653e+00
$ print $((PI))
3.141592653
```

另外，当你定义了整型变量，而后使用浮点数给它赋值时，将会发生向下取整(注意:不是四舍五入)。
```zsh
$ typeset -i n
$ n=1.99 ; print $n
1
```

如果并没有声明变量类型，它会在第一次赋值时决定. 我们来看个例子:
```zsh
#!/bin/zsh
for (( i=0; i<=1; i+=0.1 )) do
    print $i
done
```

运行一下这个脚本，是不是死循环了？ 因为i=0时， i被认定为整数， 而后i=i+0.1被向下取整变成0, 所以跳不出循环了.
我们稍微修改下:
```
#!/bin/zsh
i=""
for (( i=0; i<=1; i+=0.1 )) do
    print $i
done
```

运行看结果:
```zsh
0
0.10000000000000001
0.20000000000000001
0.30000000000000004
0.40000000000000002
0.5
0.59999999999999998
0.69999999999999996
0.79999999999999993
0.89999999999999991
0.99999999999999989
```
上面的做法只是声明i不是整数，是奸计, 正确的做法应当设置i=0.0之类的浮点数，
程序设计中一定要尽可能明确变量类型。否则有可能产生莫名其妙的结果。

## 字面量: ##char
字符本质上是整数，很多语言中都可以将二者转换，在zsh中这一过程通过##运算来完成.
```zsh
# 想看看a的ASCII码值?
$ print $(( ##a ))
97
$ print $(( ##b - ##a ))
1

# Ctrl-C
$ print $(( ##^C ))
3
```

> 注意1: `-3**2`求值后为9而非-9, 还是多加几个括号，写清楚吧
> 注意2: zsh中还有一个常用的求列表/字符串长度的方法，不要把二者混淆


```zsh
$ s="abcdefg"
# $#s 或 ${#s}都可以
$ print $#s
7
```

## 调用数学函数
zsh中默认是没有定义任何数学函数的，光靠上面提供的那些运算符还是有些单薄。 可以使用`zsh/mathfunc`来引入丰富的数学函数。
```zsh
$ zmodload zsh/mathfunc
$ print $(( sin(1) ))
0.8414709848078965
```

## 不是哪里都需要
数组的下标是整数值，因此凡是出现在[]中的单算数表达式都不必放在"(()）"中。
```sh
$ echo $xs[4/2]
2
```
