---
title: os_7788
tags:
---
# Code Injection
```sh
$ gcc -fPIC -shared shared.c -o shared.so
$ gcc app.c ./shared.so -o app
```
```
$./app
$ gdb
 Address Flags   Offset Device   Inode     Rss     Pss Referenced Anonymous    Swap  Locked Description
08048000  r-xp 00000000  08:17 9846325       4       4          4         0       0       0 /data/src/c/injection/app
08049000  rw-p 00000000  08:17 9846325       4       4          4         4       0       0 /data/src/c/injection/app
b753c000  rw-p 00000000  00:00       0       4       4          4         4       0       0 
b753d000  r-xp 00000000  08:12  919634     220       4        220         0       0       0 /usr/lib/libc-2.17.so
b76e8000  r--p 001ab000  08:12  919634       8       8          8         8       0       0 /usr/lib/libc-2.17.so
b76ea000  rw-p 001ad000  08:12  919634       4       4          4         4       0       0 /usr/lib/libc-2.17.so
b76eb000  rw-p 00000000  00:00       0       8       8          8         8       0       0 
b7706000  rw-p 00000000  00:00       0       4       4          4         4       0       0 
b7707000  r-xp 00000000  08:17 9846319       4       4          4         0       0       0 /data/src/c/injection/shared.so
b7708000  rw-p 00000000  08:17 9846319       4       4          4         4       0       0 /data/src/c/injection/shared.so
b7709000  rw-p 00000000  00:00       0       4       4          4         4       0       0 
b770a000  r-xp 00000000  00:00       0       4       0          4         0       0       0 [vdso]
b770b000  r-xp 00000000  08:12  919676     104       2        104         0       0       0 /usr/lib/ld-2.17.so
b772b000  r--p 0001f000  08:12  919676       4       4          4         4       0       0 /usr/lib/ld-2.17.so
b772c000  rw-p 00020000  08:12  919676       4       4          4         4       0       0 /usr/lib/ld-2.17.so
bf9a8000  rw-p 00000000  00:00       0      12      12         12        12       0       0 [stack]
                                       ======= ======= ========== ========= ======= ======= 
                                           396      74        396        60       0       0 KB
```
```
# O_RDWR = 2
(gdb) call open("injection.o",2)
$1 = 3 
(gdb) call mmap(0, 1012, 1 | 2 | 4, 1, 3, 0)
$2 = -1217376256
```
```sh
$ pmap -X 1568
1568:   ./app
 Address Flags   Offset Device   Inode     Rss     Pss Referenced Anonymous    Swap  Locked Description
08048000  r-xp 00000000  08:17 9846325       4       4          4         0       0       0 /data/src/c/injection/app
08049000  rw-p 00000000  08:17 9846325       4       4          4         4       0       0 /data/src/c/injection/app
0958d000  rw-p 00000000  00:00       0       4       4          4         4       0       0 [heap]
b753c000  rw-p 00000000  00:00       0       4       4          4         4       0       0
b753d000  r-xp 00000000  08:12  919634     256       9        256         4       0       0 /usr/lib/libc-2.17.so
b76e8000  r--p 001ab000  08:12  919634       8       8          8         8       0       0 /usr/lib/libc-2.17.so
b76ea000  rw-p 001ad000  08:12  919634       4       4          4         4       0       0 /usr/lib/libc-2.17.so
b76eb000  rw-p 00000000  00:00       0       8       8          8         8       0       0
b7705000  rwxs 00000000  08:17 9846320       0       0          0         0       0       0 /data/src/c/injection/injection.o
b7706000  rw-p 00000000  00:00       0       4       4          4         4       0       0
b7707000  r-xp 00000000  08:17 9846319       4       4          4         0       0       0 /data/src/c/injection/shared.so
b7708000  rw-p 00000000  08:17 9846319       4       4          4         4       0       0 /data/src/c/injection/shared.so
b7709000  rw-p 00000000  00:00       0       4       4          4         4       0       0
b770a000  r-xp 00000000  00:00       0       4       0          4         0       0       0 [vdso]
b770b000  r-xp 00000000  08:12  919676     104       6        104         4       0       0 /usr/lib/ld-2.17.so
b772b000  r--p 0001f000  08:12  919676       4       4          4         4       0       0 /usr/lib/ld-2.17.so
b772c000  rw-p 00020000  08:12  919676       4       4          4         4       0       0 /usr/lib/ld-2.17.so
bf9a8000  rw-p 00000000  00:00       0      12      12         12        12       0       0 [stack]
                                       ======= ======= ========== ========= ======= =======
                                           436      87        436        72       0       0 KB
```
```sh
$  readelf -r app 
Relocation section '.rel.dyn' at offset 0x3c8 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049824  00000406 R_386_GLOB_DAT    00000000   __gmon_start__
Relocation section '.rel.plt' at offset 0x3d0 contains 5 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049834  00000207 R_386_JUMP_SLOT   00000000   sleep
08049838  00000307 R_386_JUMP_SLOT   00000000   puts
0804983c  00000407 R_386_JUMP_SLOT   00000000   __gmon_start__
08049840  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main
08049844  00000607 R_386_JUMP_SLOT   00000000   func
```
 * fun : 
  * 08049844
  * R_386_JUMP_SLOT
```
# SBäºï¼æ²¡è¾åºç¬¦å·è¡¨, çä¸ä¸funcå½æ°çå°å
(gdb) p & func
$11 = (<text variable, no debug info> *) 0xb770754c <func>
```
# æåæ³¨å¥
---- 
08048000  r-xp 00000000  08:17 9846325       4       4          4         0       0       0 /data/src/c/injection/app
08049000  rw-p 00000000  08:17 9846325       4       4          4         4       0       0 /data/src/c/injection/app
08bf1000  rw-p 00000000  00:00       0       4       4          4         4       0       0 [heap]
b75fa000  rw-p 00000000  00:00       0       4       4          4         4       0       0
b75fb000  r-xp 00000000  08:12  919634     256       9        256         4       0       0 /usr/lib/libc-2.17.so
b77a6000  r--p 001ab000  08:12  919634       8       8          8         8       0       0 /usr/lib/libc-2.17.so
b77a8000  rw-p 001ad000  08:12  919634       4       4          4         4       0       0 /usr/lib/libc-2.17.so
b77a9000  rw-p 00000000  00:00       0       8       8          8         8       0       0
b77c3000  rwxs 00000000  08:17 9846320       0       0          0         0       0       0 /data/src/c/injection/injection.o
b77c4000  rw-p 00000000  00:00       0       4       4          4         4       0       0
b77c5000  r-xp 00000000  08:17 9846319       4       4          4         0       0       0 /data/src/c/injection/shared.so
b77c6000  rw-p 00000000  08:17 9846319       4       4          4         4       0       0 /data/src/c/injection/shared.so
b77c7000  rw-p 00000000  00:00       0       4       4          4         4       0       0
b77c8000  r-xp 00000000  00:00       0       4       0          4         0       0       0 [vdso]
b77c9000  r-xp 00000000  08:12  919676     104       6        104         4       0       0 /usr/lib/ld-2.17.so
b77e9000  r--p 0001f000  08:12  919676       4       4          4         4       0       0 /usr/lib/ld-2.17.so
b77ea000  rw-p 00020000  08:12  919676       4       4          4         4       0       0 /usr/lib/ld-2.17.so
bfde4000  rw-p 00000000  00:00       0      12      12         12        12       0       0 [stack]
                                       ======= ======= ========== ========= ======= =======
                                           436      87        436        72       0       0 KB
```
(gdb) p & func
$3 = (void (*)()) 0xb77c554c <func>
# æ¥ç funcçå°å
(gdb) p & func
$3 = (void (*)()) 0xb77c554c <func>
```
```
$ readelf -r app                                                                                                                                      ~src/c/injection
Relocation section '.rel.dyn' at offset 0x3c8 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049824  00000406 R_386_GLOB_DAT    00000000   __gmon_start__
Relocation section '.rel.plt' at offset 0x3d0 contains 5 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049834  00000207 R_386_JUMP_SLOT   00000000   sleep
08049838  00000307 R_386_JUMP_SLOT   00000000   puts
0804983c  00000407 R_386_JUMP_SLOT   00000000   __gmon_start__
08049840  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main
08049844  00000607 R_386_JUMP_SLOT   00000000   func
# ççè¿ä¸ªVMAå¯¹åºçç©çå°å, æ­£å¥½æ¯funcçå°åï¼æ¨éæ
(gdb) p/x * 0x08049844
$4 = 0xb77c554c
æ¥ä¸æ¥æä»¬æ0xb77c554cç©çå°åçå¼ï¼æ¹ä¸ºhello_funcåºè¯¥å°±å¯ä»¥OKäº
çä¸ä¸injection.o:
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 000014 00  AX  0   0  4
  [ 2] .rel.text         REL             00000000 0003dc 000010 08     11   1  4
  [ 3] .data             PROGBITS        00000000 000048 000000 00  WA  0   0  4
  [ 4] .bss              NOBITS          00000000 000048 000000 00  WA  0   0  4
  [ 5] .rodata           PROGBITS        00000000 000048 000012 00   A  0   0  1
  [ 6] .comment          PROGBITS        00000000 00005a 000012 01  MS  0   0  1
  [ 7] .note.GNU-stack   PROGBITS        00000000 00006c 000000 00      0   0  1
  [ 8] .eh_frame         PROGBITS        00000000 00006c 000038 00   A  0   0  4
  [ 9] .rel.eh_frame     REL             00000000 0003ec 000008 08     11   8  4
  [10] .shstrtab         STRTAB          00000000 0000a4 00005f 00      0   0  1
  [11] .symtab           SYMTAB          00000000 00030c 0000b0 10     12   9  4
  [12] .strtab           STRTAB          00000000 0003bc 00001d 00      0   0  1
åå¾æ¾å°.textæ®µï¼ æ¥çä¸ä¸ï¼ .textæ®µä½äº.oç0x000034è¿ä¸ªåç§», å æ­¤:
$ objdump -d injection.o                                                                                                                          ~src/c/injection:[1]
injection.o:     file format elf32-i386
Disassembly of section .text:
00000000 <hello_func>:
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   83 ec 18                sub    $0x18,%esp
   6:   c7 04 24 00 00 00 00    movl   $0x0,(%esp)
   d:   e8 fc ff ff ff          call   e <hello_func+0xe>
  12:   c9                      leave  
  13:   c3                      ret    
  çå°äºæ, .textæ®µå¼å§å°±æ¯hello_func, æä»¥hello_funcçå°ååºè¯¥æ¯:
  injection.oè£è½½å°å + 0x34
08048000      4K r-x--  /data/src/c/injection/app
08049000      4K rw---  /data/src/c/injection/app
08bf1000    132K rw---    [ anon ]
b75fa000      4K rw---    [ anon ]
b75fb000   1708K r-x--  /usr/lib/libc-2.17.so
b77a6000      8K r----  /usr/lib/libc-2.17.so
b77a8000      4K rw---  /usr/lib/libc-2.17.so
b77a9000     12K rw---    [ anon ]
b77c3000      4K rwxs-  /data/src/c/injection/injection.o
b77c4000      4K rw---    [ anon ]
b77c5000      4K r-x--  /data/src/c/injection/shared.so
b77c6000      4K rw---  /data/src/c/injection/shared.so
b77c7000      4K rw---    [ anon ]
b77c8000      4K r-x--    [ anon ]
b77c9000    128K r-x--  /usr/lib/ld-2.17.so
b77e9000      4K r----  /usr/lib/ld-2.17.so
b77ea000      4K rw---  /usr/lib/ld-2.17.so
bfde4000    136K rw---    [ stack ]
 total     2172K
(gdb) set *0x08049844 = 0xb77c3000 + 0x000034
å¥½äºï¼è·³è½¬å·²ç»çæäºï¼ä½æ¯æä»¬è¿æäºå·¥ä½.
$  readelf -S injection.o
There are 13 section headers, starting at offset 0x104:
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 000014 00  AX  0   0  4
  [ 2] .rel.text         REL             00000000 0003dc 000010 08     11   1  4
  [ 3] .data             PROGBITS        00000000 000048 000000 00  WA  0   0  4
  [ 4] .bss              NOBITS          00000000 000048 000000 00  WA  0   0  4
  [ 5] .rodata           PROGBITS        00000000 000048 000012 00   A  0   0  1
  [ 6] .comment          PROGBITS        00000000 00005a 000012 01  MS  0   0  1
  [ 7] .note.GNU-stack   PROGBITS        00000000 00006c 000000 00      0   0  1
  [ 8] .eh_frame         PROGBITS        00000000 00006c 000038 00   A  0   0  4
  [ 9] .rel.eh_frame     REL             00000000 0003ec 000008 08     11   8  4
  [10] .shstrtab         STRTAB          00000000 0000a4 00005f 00      0   0  1
  [11] .symtab           SYMTAB          00000000 00030c 0000b0 10     12   9  4
  [12] .strtab           STRTAB          00000000 0003bc 00001d 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
$ readelf -r injection.o
Relocation section '.rel.text' at offset 0x3dc contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00000009  00000501 R_386_32          00000000   .rodata
0000000e  00000a02 R_386_PC32        00000000   puts <-- putsä¸­ä½¿ç¨çå¸¸é
Relocation section '.rel.eh_frame' at offset 0x3ec contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00000020  00000202 R_386_PC32        00000000   .text
```
Note that system and print relocations are of R_386_PC32 type. This means that the value (resolved address) to be set into the relocation location should be calculated relatively to the PC program counter, that is relatively to the relocation location. Also R_386_PC32 relocation requires that the value that was stored in the relocation location before relocation resolution (addend) should be added to the resolved address. The R_386_32 .rodata relocation also adds the addend to its resolved address.
```
# éæ°ç¡®å®putså½æ°çå°å
(gdb) p & puts
$8 = (<text variable, no debug info> *) 0xb7662e40 <puts>
# æ¢ç¶putså½æ°ä½äº0xb7662e40, injection.oçè£è½½ä½ç½®ä¸º: 0xb77c3000 .textæ®µä½äº0x000034, .rodataæ®µä½äº.textæ®µèµ·å§å¤åç§»00000009ï¼ å 
(gdb) set *(0xb77c3000 + 0x000034 + 0x0000000e) = 0xb7662e40 - (0xb77c3000 + 0x000034 + 0x0000000e) - 4
# éæ°ç¡®å®.rodataæ®µçå°å
(gdb) set *(0xb77c3000 + 0x000034 + 0x00000009) = 0xb77c3000 + 0x000048
(gdb) quit
```
ååï¼funcå½æ°è¢«æä»¬æ¢æäº
```
[1765] : n=0
[1765] : n=1
[1765] : n=2
[1765] : n=3
[1765] : n=4
from the hell ...
from the hell ...
from the hell ...
from the hell ...
from the hell ...
```
[[TOC]]
# 80x86
# å¯å­å¨
# éç¨å¯å­å¨
# EAX: 32ä½
 * AX
  * AH
  * AL
# EBX: 32ä½
 * BX
  * BH
  * BL
# ECX: 32ä½
 * CX
  * CH
  * CL
# EDX: 32ä½
 * DX
  * DH
  * DL
# ESI: 32ä½
 * SI
# EDI: 32ä½
 * DI
# EBP: 32ä½
 * BP
# ESP: 32ä½
 * SP
# æ®µå¯å­å¨
# CS: 16ä½
# DS: 16ä½
# SS: 16ä½
# ES: 16ä½
# FS: 16ä½
# GS: 16ä½
# EIP: 32ä½
ä¼ è¯´ä¸­çPC, å½åæ§è¡çæä»¤å°å.
# EFLAG
||31|| ||ä¿ç
|| ... || ||ä¿ç
||22|| ||ä¿ç
||21||IF ||  ||
||20||VIP || èæä¸­æ­ç­å¾
||19||VIF || èæä¸­æ­
||18||AC || å¯¹é½æ£æ¥
||17||VM||èæ8086æ¨¡å¼
||16||RF || æ¢å¤æ å¿
||15|| ||ä¿ç ||
||14||NT || åµå¥ä»»å¡æ å¿ || 
||13||IOPL || IOç¹æ
||12||IOPL || IOç¹æ
||11||`OF` || æº¢åºæ å¿
||10||`DF` ||æ¹åæ å¿
||9||`IF` || ä¸­æ­æ å¿
||8||TF||è·è¸ªæ å¿
||7||`SF`|| ç¬¦å·æ å¿ ||
||6||`ZF`|| é¶æ å¿
||5|| ||ä¿ç
||4||`AF`||è¾å©è¿ä½æ å¿
||3|| ||ä¿ç
||2||`PF` || å¥å¶æ å¿
||1|| ||ä¿ç
||0||`CF`||è¿ä½æ å¿
# æ§å¶å¯å­å¨
# CR0
# CR1
# CR2
# CR3
# CR4
# GDTR
# IDTR
# TR
# LDTR
# è°è¯å¯å­å¨
# DR0
# DR1
# DR2
# DR3
# DR4
# DR5
# DR6
# DR7
# Stack Frame
StackFrameå°±æ¯ä¼ è¯´ä¸­çæ å¸§ï¼ å®æ¯æ ä¸­çä¸ä¸ªçæ®µãæ¢ç¶æ¯çæ®µå°±è¦æèµ·å§å°ååç»æå°åï¼ å¨æ ä¸­æå¤ä¸ªæ å¸§ï¼æä»¬åªéè¦å³å¿æé¡¶å±çé£ä¸ªã è¿ä¸ªé¡¶å±çStackFrameä¿å­äºå½åå½æ°çä¸äºå¿è¦çä¿¡æ¯ï¼å®çèµ·å§å°åæ¯$EBPï¼ ç»æå°åæ¯$ESP.  $ESPå°±æ¯æ é¡¶ã
ä¸è¬çå½æ°è°ç¨ä¼äº§çæ°çStackFrame, å¶ä¸­ä¿å­äºè¯¸å¦è°ç¨åæ°ï¼ä¹åç$EBPï¼(å ä¸ºå½æ°ç»æåè¿è¦åå°ä¸å±å½æ°å)ã
éå¸¸ç¼è¯å¨å¸®ä½ æå®äºè¿äºäºå¿ï¼ä»¥è³äºä½ æ ¹æ¬æ²¡ææ³¨æå°ESPåEBPçååï¼ å¯ä»¥åæ±ç¼æ¥çç:
```cpp
int func(int x) {
    int m=1;
    int n=2;
    return 1+2;
}
int main() {
   func(128);
   return 0;
}
```
```sh
$ gcc a.c
$ objdump -d a.out
```
```
080483cc <func>:
 80483cc:       55                      push   %ebp
 80483cd:       89 e5                   mov    %esp,%ebp
 80483cf:       83 ec 10                sub    $0x10,%esp
 80483d2:       c7 45 fc 01 00 00 00    movl   $0x1,-0x4(%ebp)
 80483d9:       c7 45 f8 02 00 00 00    movl   $0x2,-0x8(%ebp)
 80483e0:       8b 45 f8                mov    -0x8(%ebp),%eax
 80483e3:       8b 55 fc                mov    -0x4(%ebp),%edx
 80483e6:       01 d0                   add    %edx,%eax
 80483e8:       c9                      leave  
 80483e9:       c3                      ret    
080483ea <main>:
 80483ea:       55                      push   %ebp
 80483eb:       89 e5                   mov    %esp,%ebp
 80483ed:       83 ec 04                sub    $0x4,%esp
 80483f0:       c7 04 24 80 00 00 00    movl   $0x80,(%esp)
 80483f7:       e8 d0 ff ff ff          call   80483cc <func>
 80483fc:       b8 00 00 00 00          mov    $0x0,%eax
 8048401:       c9                      leave  
 8048402:       c3                      ret    
 8048403:       66 90                   xchg   %ax,%ax
 8048405:       66 90                   xchg   %ax,%ax
 8048407:       66 90                   xchg   %ax,%ax
 8048409:       66 90                   xchg   %ax,%ax
 804840b:       66 90                   xchg   %ax,%ax
 804840d:       66 90                   xchg   %ax,%ax
 804840f:       90                      nop
```
æ³¨æå½æ°å¼å¤´çä¸æ¡æä»¤:
```
push %ebp                  : ä¿å­å½åç$EBP
mov  %ebp, %esp            : å°EBPè®¾ç½®ä¸º$ESP, æ­¤æ¶EBPåESPé½æåäºæ é¡¶
sub  <size>, %esp          : ä¿®æ¹ESPå°±æ¯æ¹åæ çå¤§å°ï¼ä»èå¼è¾äºæ°çæ å¸§ 
```
[[TOC]]
# å¨æé¾æ¥
éæé¾æ¥ï¼æ¹æ³ç®åï¼ä½æ¯ä¸è½å¤§è§æ¨¡çä½¿ç¨ãå ä¸ºï¼
 1. æµªè´¹èµæºãç¸åçä»£ç ä¸åæ¶èå­å¨ç©ºé´ï¼èä¸æµªè´¹åå­ç©ºé´ã
 2. ç»´æ¤ä¸å¾è®©äººææ¥ï¼éæåºçä»»ä½åå¨é½è¦ä¼å¯¼è´æ´ä¸ªç¨åºéæ°ç¼è¯ï¼åå¸ï¼ç¸å½ä¸çµæ´»ã
åè¾ä»¬å¼å¥äºå¨æé¾æ¥æ¥å¼¥è¡¥éæé¾æ¥çä¸è¶³ã
# Dll Hell
å¨æé¾æ¥çè´ä½ç¨ä¹ä¸ä¾¿æ¯è®©ä½¿ç¨åä¸ä¸ªå±äº«åºçä¸åç¨åºä¹é´äº§çäºè¦åã å¦æç¼ºä¹æççå¨æåºç®¡çæ¹æ³ï¼å°±ä¼åºç°å½æä¸ªç¨åºæ´æ°å±äº«åºä¹åå¯¼è´å¶ä»ä¾èµæ§çæ¬åºçåºç¨æ æ³è¿è¡ãè¿äºå¿å¨æ©æwindowsä¸æ¶æåçï¼è¢«æä¸ºDllHell.
# å¦ä½æè½å®ç°å¨æé¾æ¥
# DSO
è½å¤å¨æè½½å¥VMAçç®æ æä»¶(ObjectFile)æä¸ºDSO(DynamicSharedObjects). å¨linuxä¸éå¸¸ä»¥.soä¸ºåç¼åã
# å»¶è¿ç»å®(Lazy Binding)
å¨éè¦è®¿é®å±äº«åºä»£ç çæ¶åæä½¿ç¨å¨æé¾æ¥å¨å°å¨æåºè½½å¥VMAçææ¯æä¸º`å»¶è¿ç»å®`ã
# ç¼ååä½¿ç¨å±äº«åº
lib.h:
```c
#ifndef LIB_H
#define LIB_H
    void func();
#endif
```
lib.c:
```c
#include <stdio.h>
void func(char * text) {
    puts(text);
}
```
p.c:
```c
#include "lib.h"
int main() {
    func("hello this is p");
    return 0;
}
```
q.c
```c
#include "lib.h"
int main() {
    func("hello this is q");
    return 0;
}
```
ç¼è¯:
```sh
$ gcc -fPIC -shared lib.c -o lib.so
$ gcc p.c ./lib.so -o p
$ gcc q.c ./lib.so -o q
```
è¿è¡:
```sh
$ ./p
hello this is p
$ ./q
hello this is q
```
ä¸ºäºæ´å ä»ç»çè§å¯påqçå®éè¿è¡æåµï¼æä»¬æ¥ä¿®æ¹ä¸ä¸lib.c:
```c
#include <stdio.h>
void func(char * text) {
    puts(text);
    sleep(-1);
}
```
å¨æé¾æ¥ä¼å¿ç«ç°ï¼æä»¬åªéè¦éæ°ç¼è¯lib.soå°±å¯ä»¥äº:
```sh
$ gcc -fPIC -shared lib.c -o lib.so
$ ./p &
[1] 1155
hello this is p                                                                                                                                                        
$ ./q &
[2] 1157
hello this is q 
```
æ¥ä¸æ¥ï¼æä»¬åæä¸ä¸p,qè¿ä¸¤åªè¿ç¨:
||= p(pid=1155) =||= q(pid=1157) =||
```td
```
08048000-08049000  r-xp  00000000  08:17  9846308  /data/src/c/so/p
08049000-0804a000  rw-p  00000000  08:17  9846308  /data/src/c/so/p
b75b9000-b75ba000  rw-p  00000000  00:00  0
b75ba000-b7765000  r-xp  00000000  08:12  919634   /usr/lib/libc-2.17.so
b7765000-b7767000  r--p  001ab000  08:12  919634   /usr/lib/libc-2.17.so
b7767000-b7768000  rw-p  001ad000  08:12  919634   /usr/lib/libc-2.17.so
b7768000-b776b000  rw-p  00000000  00:00  0
b7783000-b7784000  rw-p  00000000  00:00  0
b7784000-b7785000  r-xp  00000000  08:17  9846310  /data/src/c/so/lib.so
b7785000-b7786000  rw-p  00000000  08:17  9846310  /data/src/c/so/lib.so
b7786000-b7787000  rw-p  00000000  00:00  0
b7787000-b7788000  r-xp  00000000  00:00  0        [vdso]
b7788000-b77a8000  r-xp  00000000  08:12  919676   /usr/lib/ld-2.17.so
b77a8000-b77a9000  r--p  0001f000  08:12  919676   /usr/lib/ld-2.17.so
b77a9000-b77aa000  rw-p  00020000  08:12  919676   /usr/lib/ld-2.17.so
bfc66000-bfc88000  rw-p  00000000  00:00  0        [stack]
```
```
```td
```
08048000-08049000  r-xp  00000000  08:17  9846309  /data/src/c/so/q
08049000-0804a000  rw-p  00000000  08:17  9846309  /data/src/c/so/q
b75f8000-b75f9000  rw-p  00000000  00:00  0
b75f9000-b77a4000  r-xp  00000000  08:12  919634   /usr/lib/libc-2.17.so
b77a4000-b77a6000  r--p  001ab000  08:12  919634   /usr/lib/libc-2.17.so
b77a6000-b77a7000  rw-p  001ad000  08:12  919634   /usr/lib/libc-2.17.so
b77a7000-b77aa000  rw-p  00000000  00:00  0
b77c2000-b77c3000  rw-p  00000000  00:00  0
b77c3000-b77c4000  r-xp  00000000  08:17  9846310  /data/src/c/so/lib.so
b77c4000-b77c5000  rw-p  00000000  08:17  9846310  /data/src/c/so/lib.so
b77c5000-b77c6000  rw-p  00000000  00:00  0
b77c6000-b77c7000  r-xp  00000000  00:00  0        [vdso]
b77c7000-b77e7000  r-xp  00000000  08:12  919676   /usr/lib/ld-2.17.so
b77e7000-b77e8000  r--p  0001f000  08:12  919676   /usr/lib/ld-2.17.so
b77e8000-b77e9000  rw-p  00020000  08:12  919676   /usr/lib/ld-2.17.so
bfe09000-bfe2b000  rw-p  00000000  00:00  0        [stack]
```
```
----
||= p =||
```td
```sh
$ readelf -l p
Elf file type is EXEC (Executable file)
Entry point 0x8048420
There are 8 program headers, starting at offset 52
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4
  INTERP         0x000134 0x08048134 0x08048134 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x006bc 0x006bc R E 0x1000
  LOAD           0x0006bc 0x080496bc 0x080496bc 0x00120 0x00124 RW  0x1000
  DYNAMIC        0x0006c8 0x080496c8 0x080496c8 0x000f0 0x000f0 RW  0x4
  NOTE           0x000148 0x08048148 0x08048148 0x00044 0x00044 R   0x4
  GNU_EH_FRAME   0x0005e0 0x080485e0 0x080485e0 0x0002c 0x0002c R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame 
   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag .note.gnu.build-id 
   06     .eh_frame_hdr 
   07 
```
```
||= lib.so =||
```td
```sh
$ readelf -l lib.so
Elf file type is DYN (Shared object file)
Entry point 0x420
There are 6 program headers, starting at offset 52
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x00000000 0x00000000 0x00610 0x00610 R E 0x1000
  LOAD           0x000610 0x00001610 0x00001610 0x00120 0x00124 RW  0x1000
  DYNAMIC        0x00061c 0x0000161c 0x0000161c 0x000e0 0x000e0 RW  0x4
  NOTE           0x0000f4 0x000000f4 0x000000f4 0x00024 0x00024 R   0x4
  GNU_EH_FRAME   0x000590 0x00000590 0x00000590 0x0001c 0x0001c R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .eh_frame_hdr .eh_frame 
   01     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 
   02     .dynamic 
   03     .note.gnu.build-id 
   04     .eh_frame_hdr 
   05
```
```
çèµ·æ¥soæä»¶åå¯æ§è¡çelfæä»¶æ²¡å¤ªå¤§åºå«åã
# å¯æ§è¡æä»¶çEntry Pointä¸ºä»ä¹æ¯0x80xxxxxå¢ï¼
```div class=note
On 386 systems, the text base address is 0x08048000, which permits a reasonably large stack below the text while still staying above address 0x08000000, permitting most programs to use a single second-level page table. (Recall that on the 386, each second-level table maps 0x00400000 addresses.)
See: [http://www.iecc.com/linker/linker04.html]
```
 1. å¥å£ç¹å³æ´ä¸ªELFçæ§è¡å¼å§å¤ï¼å¦æä¸ååå¤å°±ç»ªï¼OSåªéè¦æPCè®¡æ°å¨è®¾ä¸ºå¥å£ç¹å°åï¼æ´ä¸ªç¨åºå°±å¯ä»¥å¼å§æ§è¡äº
 2. ELFçEntryPointæ¯ä¸ä¸ªåç§»éï¼è¿ä¸ªå¼å ä¸0x08000000ï¼ å°±æ¯æ´ä¸ªç¨åºçå¥å£ï¼æèè¯´.textæ®µçVMA.
ç¨objdump -dæ¥çä¸ä¸p, .textæ®µå§äº0x8048420=0x8048000+420, æä»¥æ´ä¸ªELFçå¥å£å½æ°å¹¶ä¸æ¯mainå½æ°ï¼èæ¯_startå½æ°.
```
Disassembly of section .text:
08048420 <_start>:
 8048420:       31 ed                   xor    %ebp,%ebp
 8048422:       5e                      pop    %esi
 8048423:       89 e1                   mov    %esp,%ecx
 8048425:       83 e4 f0                and    $0xfffffff0,%esp
 8048428:       50                      push   %eax
 8048429:       54                      push   %esp
 804842a:       52                      push   %edx
 804842b:       68 b0 85 04 08          push   $0x80485b0
 8048430:       68 40 85 04 08          push   $0x8048540
 8048435:       51                      push   %ecx
 8048436:       56                      push   %esi
 8048437:       68 1c 85 04 08          push   $0x804851c
 804843c:       e8 bf ff ff ff          call   8048400 <__libc_start_main@plt>
 8048441:       f4                      hlt    
 8048442:       66 90                   xchg   %ax,%ax
 8048444:       66 90                   xchg   %ax,%ax
 8048446:       66 90                   xchg   %ax,%ax
 8048448:       66 90                   xchg   %ax,%ax
 804844a:       66 90                   xchg   %ax,%ax
 804844c:       66 90                   xchg   %ax,%ax
 804844e:       66 90                   xchg   %ax,%ax
```
# å¦ä½çæå°åæ å³ä»£ç 
# æ¨¡ååé¨è·³è½¬
# æ¨¡ååé¨çæ°æ®è®¿é®
# æ¨¡åé´æ°æ®è®¿é®
# æ¨¡åé´è·³è½¬
# å¨æé¾æ¥å¨çå¥å£ .interp Setion
```sh
$ objdump -s -j .interp p
Contents of section .interp:
 8048134 2f6c6962 2f6c642d 6c696e75 782e736f  /lib/ld-linux.so
 8048144 2e3200
```
å¨æé¾æ¥å¨ç±ELFæä»¶ä¸­ç.interpæ®µæ¥è®¾å®ï¼æä»¬çå°`/lib/ld-linux.so`å°±æ¯æä»¬å¯»æ¾çå¨æé¾æ¥å¨ã
# .dynamic Section
```sh
$ readelf -d p
Dynamic section at offset 0x6c8 contains 25 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [./lib.so]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x80483b4
 0x0000000d (FINI)                       0x80485b4
 0x00000019 (INIT_ARRAY)                 0x80496bc
 0x0000001b (INIT_ARRAYSZ)               4 (bytes)
 0x0000001a (FINI_ARRAY)                 0x80496c0
 0x0000001c (FINI_ARRAYSZ)               4 (bytes)
 0x6ffffef5 (GNU_HASH)                   0x804818c
 0x00000005 (STRTAB)                     0x8048298
 0x00000006 (SYMTAB)                     0x80481c8
 0x0000000a (STRSZ)                      193 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000015 (DEBUG)                      0x0
 0x00000003 (PLTGOT)                     0x80497bc
 0x00000002 (PLTRELSZ)                   24 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x804839c
 0x00000011 (REL)                        0x8048394
 0x00000012 (RELSZ)                      8 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x8048374
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x804835a
 0x00000000 (NULL)                       0x0
$ readelf -d lib.so
Dynamic section at offset 0x61c contains 24 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x3a0
 0x0000000d (FINI)                       0x57c
 0x00000019 (INIT_ARRAY)                 0x1610
 0x0000001b (INIT_ARRAYSZ)               4 (bytes)
 0x0000001a (FINI_ARRAY)                 0x1614
 0x0000001c (FINI_ARRAYSZ)               4 (bytes)
 0x6ffffef5 (GNU_HASH)                   0x118
 0x00000005 (STRTAB)                     0x234
 0x00000006 (SYMTAB)                     0x154
 0x0000000a (STRSZ)                      189 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000003 (PLTGOT)                     0x1710
 0x00000002 (PLTRELSZ)                   32 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x380
 0x00000011 (REL)                        0x340
 0x00000012 (RELSZ)                      64 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x310
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x2f2
 0x6ffffffa (RELCOUNT)                   3
 0x00000000 (NULL)                       0x0
```
[[TOC]]
# Executable Linkable Format
æ¯ä¸ç§å¯æ§è¡æä»¶æ ¼å¼ï¼æºèª[wiki:Os/Coff].
# åå²
æå¾è¡¥å
# ELFæä»¶ç±»å
helloworld.c:
```c
#include <stdio.h>
int main() {
  printf("hello world!
");
  return 0;
}
```
# å¯éå®ä½æä»¶: Relocatable File
```sh
$ gcc -c helloword.c
$ file helloworld.o
helloworld.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped
```
# å¯æ§è¡æä»¶: Executable File
```sh
$ gcc helloworld.c
$ file a.out
a.out: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, 
BuildID[sha1]=0xf9c86e3076c17d8147ad8b3d5464934ce74e4486, not stripped
$ ls -l a.out
-rwxr-xr-x 1 user users 4.8K Aug 26 23:05 a.out
```
# å±äº«ç®æ æä»¶: Shared Object File
```sh
$ gcc -shared helloworld.c -o helloworld.so
$ file helloworld.so
helloworld.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, 
BuildID[sha1]=0x1292ede3037cbe9eff894171d7687dfa9f7530ee, not stripped
```
# æ ¸å¿è½¬å¨æä»¶: Core Dump File
# ELFæä»¶æ ¼å¼
```c
#include<stdio.h>
int gX=1900;
int gY;
int func(void) {
    puts("call func");
}
int main(void) {
    static int sX=1983;
    static int sY;
    func();
    return 42;
}
```
# è§å¯ELFå¤´ä¿¡æ¯: objdump -h
```sh
$ gcc -c elf.c | column -t
$ objdump -h elf.o
elf.o:     file             format    elf32-i386
Sections:
Idx        Name             Size      VMA         LMA        File      off   Algn
0          .text            00000026  00000000    00000000   00000034  2**2
CONTENTS,  ALLOC,           LOAD,     RELOC,      READONLY,  CODE
1          .data            00000008  00000000    00000000   0000005c  2**2
CONTENTS,  ALLOC,           LOAD,     DATA
2          .bss             00000004  00000000    00000000   00000064  2**2
ALLOC
3          .rodata          0000000a  00000000    00000000   00000064  2**0
CONTENTS,  ALLOC,           LOAD,     READONLY,   DATA
4          .comment         00000012  00000000    00000000   0000006e  2**0
CONTENTS,  READONLY
5          .note.GNU-stack  00000000  00000000    00000000   00000080  2**0
CONTENTS,  READONLY
6          .eh_frame        00000058  00000000    00000000   00000080  2**2
CONTENTS,  ALLOC,           LOAD,     RELOC,      READONLY,  DATA
# æ¥çæ¯ä¸ªæ®µçå¤§å°(åä½: å­è)
$ size elf.o | column -t
text  data  bss  dec  hex  filename
136   8     4    148  94   elf.o
```
# Section
```
$ objdump -x -j <header-name> <.o>
```
# ç¬¦å·è¡¨
```sh
$ objdump -t elf.o | column -t
...
SYMBOL    TABLE:
00000000  l       df        *ABS*            00000000  elf.c
00000000  l       d         .text            00000000  .text
00000000  l       d         .data            00000000  .data
00000000  l       d         .bss             00000000  .bss
00000000  l       d         .rodata          00000000  .rodata
00000000  l       O         .bss             00000004  sY.1819
00000004  l       O         .data            00000004  sX.1818
00000000  l       d         .note.GNU-stack  00000000  .note.GNU-stack
00000000  l       d         .eh_frame        00000000  .eh_frame
00000000  l       d         .comment         00000000  .comment
00000000  g       O         .data            00000004  gX
00000004  O       *COM*     00000004         gY
00000000  g       F         .text            00000014  func
00000000  *UND*   00000000  puts
00000014  g       F         .text            00000012  main
```
|| gX || å·²åå§åçå¨å±åé || å¨`.data`æ®µ||
|| sY ||  æªåå§åçéæåé || å¨`.bss`æ®µ||
|| sX ||  å·²åå§åçéæåé || å¨`.data`æ®µ||
|| "call func" || å¸¸éå­ç¬¦ä¸² || å¨`.rodata`æ®µ||
|| func å main || å½æ° || å¨`.text`æ®µ||
# .text
```sh
# -d: è¾åºåæ±ç¼
# -x: è¾åºè¯¦æ
$ objdump -x  -d -j .text elf.o
elf.o:     file format elf32-i386
elf.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000026  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
SYMBOL TABLE:
00000000 l     d .text  00000000 .text
00000000 g     F .text  00000014 func
00000014 g     F .text  00000012 main
RELOCATION RECORDS FOR [.text]:
OFFSET   TYPE              VALUE 
00000009 R_386_32          .rodata
0000000e R_386_PC32        puts
0000001b R_386_PC32        func
```
Disassembly of section .text:
```asm
00000000 <func>:
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   83 ec 18                sub    $0x18,%esp
   6:   c7 04 24 00 00 00 00    movl   $0x0,(%esp)
                        9: R_386_32     .rodata
   d:   e8 fc ff ff ff          call   e <func+0xe>
                        e: R_386_PC32   puts
  12:   c9                      leave  
  13:   c3                      ret    
00000014 <main>:
  14:   55                      push   %ebp
  15:   89 e5                   mov    %esp,%ebp
  17:   83 e4 f0                and    $0xfffffff0,%esp
  1a:   e8 fc ff ff ff          call   1b <main+0x7>
                        1b: R_386_PC32  func
  1f:   b8 2a 00 00 00          mov    $0x2a,%eax
  24:   c9                      leave  
  25:   c3                      ret  
```
# .data
```
$ objdump -x -d -j .data elf.o
elf.o:     file format elf32-i386
elf.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  1 .data         00000008  00000000  00000000  0000005c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
00000000 l    d  .data  00000000 .data
00000004 l     O .data  00000004 sX.1818
00000000 g     O .data  00000004 gX
Disassembly of section .data:
00000000 <gX>:
   0:   6c 07 00 00                                         l...
00000004 <sX.1818>:
   4:   bf 07 00 00                                         ....
```
# .bss
# .rodata
```sh
# -s : æå°æ®µåå®¹
$ objdump -x -s -j .rodata elf.o 
...
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  3 .rodata       0000000a  00000000  00000000  00000064  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
SYMBOL TABLE:
00000000 l    d  .rodata        00000000 .rodata
Contents of section .rodata:
 0000 63616c6c 2066756e 6300               call func.
```
Disassembly of section .rodata:
```asm
00000000 <.rodata>:
   0:   63 61 6c                arpl   %sp,0x6c(%ecx)
   3:   6c                      insb   (%dx),%es:(%edi)
   4:   20 66 75                and    %ah,0x75(%esi)
   7:   6e                      outsb  %ds:(%esi),(%dx)
   8:   63 00                   arpl   %ax,(%eax)
```
# .comment
# .note.GNU-stack
# .eh_frame
# VMA
# LMA
# ELFçå è½½è¿ç¨
```
NAME
       elf - format of Executable and Linking Format (ELF) files
SYNOPSIS
       #include <elf.h>
DESCRIPTION
       The header file <elf.h> defines the format of ELF executable binary files.  Amongst these files are normal executable files, relocatable object files, core
       files and shared libraries.
       An executable file using the ELF file format consists of an ELF header, followed by a program header table or a section header table,  or  both.   The  ELF
       header  is  always  at  offset zero of the file.  The program header table and the section header table's offset in the file are defined in the ELF header.
       The two tables describe the rest of the particularities of the file.
       This header file describes the above mentioned headers as C structures and also includes structures for dynamic sections, relocation  sections  and  symbol
       tables.
       The following types are used for N-bit architectures (N=32,64, ElfN stands for Elf32 or Elf64, uintN_t stands for uint32_t or uint64_t):
           ElfN_Addr       Unsigned program address, uintN_t
           ElfN_Off        Unsigned file offset, uintN_t
           ElfN_Section    Unsigned section index, uint16_t
           ElfN_Versym     Unsigned version symbol information, uint16_t
           Elf_Byte        unsigned char
           ElfN_Half       uint16_t
           ElfN_Sword      int32_t
           ElfN_Word       uint32_t
           ElfN_Sxword     int64_t
           ElfN_Xword      uint64_t
       (Note:  The  *BSD  terminology  is  a bit different.  There Elf64_Half is twice as large as Elf32_Half, and Elf64Quarter is used for uint16_t.  In order to
       avoid confusion these types are replaced by explicit ones in the below.)
       All data structures that the file format defines follow the "natural" size and alignment guidelines for the relevant class.  If necessary, data  structures
       contain explicit padding to ensure 4-byte alignment for 4-byte objects, to force structure sizes to a multiple of 4, etc.
       The ELF header is described by the type Elf32_Ehdr or Elf64_Ehdr:
           #define EI_NIDENT 16
           typedef struct {
               unsigned char e_ident[EI_NIDENT];
               uint16_t      e_type;
               uint16_t      e_machine;
               uint32_t      e_version;
               ElfN_Addr     e_entry;
               ElfN_Off      e_phoff;
               ElfN_Off      e_shoff;
               uint32_t      e_flags;
               uint16_t      e_ehsize;
               uint16_t      e_phentsize;
               uint16_t      e_phnum;
               uint16_t      e_shentsize;
               uint16_t      e_shnum;
               uint16_t      e_shstrndx;
           } ElfN_Ehdr;
       The fields have the following meanings:
       e_ident     This  array  of bytes specifies to interpret the file, independent of the processor or the file's remaining contents.  Within this array everyâ
                   thing is named by macros, which start with the prefix EI_ and may contain values which start with the prefix ELF.   The  following  macros  are
                   defined:
                   EI_MAG0     The first byte of the magic number.  It must be filled with ELFMAG0.  (0: 0x7f)
                   EI_MAG1     The second byte of the magic number.  It must be filled with ELFMAG1.  (1: 'E')
                   EI_MAG2     The third byte of the magic number.  It must be filled with ELFMAG2.  (2: 'L')
                   EI_MAG3     The fourth byte of the magic number.  It must be filled with ELFMAG3.  (3: 'F')
                   EI_CLASS    The fifth byte identifies the architecture for this binary:
                               ELFCLASSNONE  This class is invalid.
                               ELFCLASS32    This defines the 32-bit architecture.  It supports machines with files and virtual address spaces up to 4 Gigabytes.
                               ELFCLASS64    This defines the 64-bit architecture.
                   EI_DATA     The sixth byte specifies the data encoding of the processor-specific data in the file.  Currently these encodings are supported:
                               ELFDATANONE   Unknown data format.
                               ELFDATA2LSB   Two's complement, little-endian.
                               ELFDATA2MSB   Two's complement, big-endian.
                   EI_VERSION  The version number of the ELF specification:
                               EV_NONE       Invalid version.
                               EV_CURRENT    Current version.
                   EI_OSABI    This  byte identifies the operating system and ABI to which the object is targeted.  Some fields in other ELF structures have flags
                               and values that have platform-specific meanings; the interpretation of those fields is determined by the value of this byte.  E.g.:
                               ELFOSABI_NONE       Same as ELFOSABI_SYSV
                               ELFOSABI_SYSV       UNIX System V ABI.
                               ELFOSABI_HPUX       HP-UX ABI.
                               ELFOSABI_NETBSD     NetBSD ABI.
                               ELFOSABI_LINUX      Linux ABI.
                               ELFOSABI_SOLARIS    Solaris ABI.
                               ELFOSABI_IRIX       IRIX ABI.
                               ELFOSABI_FREEBSD    FreeBSD ABI.
                               ELFOSABI_TRU64      TRU64 UNIX ABI.
                               ELFOSABI_ARM        ARM architecture ABI.
                               ELFOSABI_STANDALONE Stand-alone (embedded) ABI.
                   EI_ABIVERSION
                               This byte identifies the version of the ABI to which the object is targeted.  This field is used to distinguish among  incompatible
                               versions  of an ABI.  The interpretation of this version number is dependent on the ABI identified by the EI_OSABI field.  Applicaâ
                               tions conforming to this specification use the value 0.
                   EI_PAD      Start of padding.  These bytes are reserved and set to zero.  Programs which read them should ignore them.  The  value  for  EI_PAD
                               will change in the future if currently unused bytes are given meanings.
                   EI_NIDENT   The size of the e_ident array.
       e_type      This member of the structure identifies the object file type:
                   ET_NONE     An unknown type.
                   ET_REL      A relocatable file.
                   ET_EXEC     An executable file.
                   ET_DYN      A shared object.
                   ET_CORE     A core file.
       e_machine   This member specifies the required architecture for an individual file.  E.g.:
                   EM_NONE     An unknown machine.
                   EM_M32      AT&T WE 32100.
                   EM_SPARC    Sun Microsystems SPARC.
                   EM_386      Intel 80386.
                   EM_68K      Motorola 68000.
                   EM_88K      Motorola 88000.
                   EM_860      Intel 80860.
                   EM_MIPS     MIPS RS3000 (big-endian only).
                   EM_PARISC   HP/PA.
                   EM_SPARC32PLUS
                               SPARC with enhanced instruction set.
                   EM_PPC      PowerPC.
                   EM_PPC64    PowerPC 64-bit.
                   EM_S390     IBM S/390
                   EM_ARM      Advanced RISC Machines
                   EM_SH       Renesas SuperH
                   EM_SPARCV9  SPARC v9 64-bit.
                   EM_IA_64    Intel Itanium
                   EM_X86_64   AMD x86-64
                   EM_VAX      DEC Vax.
       e_version   This member identifies the file version:
                   EV_NONE     Invalid version.
                   EV_CURRENT  Current version.
       e_entry     This  member  gives  the virtual address to which the system first transfers control, thus starting the process.  If the file has no associated
                   entry point, this member holds zero.
       e_phoff     This member holds the program header table's file offset in bytes.  If the file has no program header table, this member holds zero.
       e_shoff     This member holds the section header table's file offset in bytes.  If the file has no section header table this member holds zero.
       e_flags     This member holds processor-specific flags associated with the file.  Flag names take the form EF_`machine_flag'.  Currently no flags have been
                   defined.
       e_ehsize    This member holds the ELF header's size in bytes.
       e_phentsize This member holds the size in bytes of one entry in the file's program header table; all entries are the same size.
       e_phnum     This  member  holds  the  number of entries in the program header table.  Thus the product of e_phentsize and e_phnum gives the table's size in
                   bytes.  If a file has no program header, e_phnum holds the value zero.
                   If the number of entries in the program header table is larger than or equal to PN_XNUM (0xffff), this member holds PN_XNUM  (0xffff)  and  the
                   real  number of entries in the program header table is held in the sh_info member of the initial entry in section header table.  Otherwise, the
                   sh_info member of the initial entry contains the value zero.
                   PN_XNUM  This is defined as 0xffff, the largest number e_phnum can have, specifying where the actual number of program headers is assigned.
       e_shentsize This member holds a sections header's size in bytes.  A section header is one entry in the section header table; all entries are the same size.
       e_shnum     This member holds the number of entries in the section header table.  Thus the product of e_shentsize and e_shnum gives the section header  taâ
                   ble's size in bytes.  If a file has no section header table, e_shnum holds the value of zero.
                   If  the  number  of entries in the section header table is larger than or equal to SHN_LORESERVE (0xff00), e_shnum holds the value zero and the
                   real number of entries in the section header table is held in the sh_size member of the initial entry in section header table.  Otherwise,  the
                   sh_size member of the initial entry in the section header table holds the value zero.
       e_shstrndx  This  member  holds the section header table index of the entry associated with the section name string table.  If the file has no section name
                   string table, this member holds the value SHN_UNDEF.
                   If the index of section name string table section is larger than or equal to SHN_LORESERVE (0xff00), this member holds SHN_XINDEX (0xffff)  and
                   the real index of the section name string table section is held in the sh_link member of the initial entry in section header table.  Otherwise,
                   the sh_link member of the initial entry in section header table contains the value zero.
                   SHN_UNDEF     This value marks an undefined, missing, irrelevant, or otherwise meaningless section reference.  For example, a symbol  "defined"
                                 relative to section number SHN_UNDEF is an undefined symbol.
                   SHN_LORESERVE This value specifies the lower bound of the range of reserved indices.
                   SHN_LOPROC    Values greater than or equal to SHN_HIPROC are reserved for processor-specific semantics.
                   SHN_HIPROC    Values less than or equal to SHN_LOPROC are reserved for processor-specific semantics.
                   SHN_ABS       This  value  specifies  absolute values for the corresponding reference.  For example, symbols defined relative to section number
                                 SHN_ABS have absolute values and are not affected by relocation.
                   SHN_COMMON    Symbols defined relative to this section are common symbols, such as Fortran COMMON or unallocated C external variables.
                   SHN_HIRESERVE This value specifies the upper bound of the range of reserved indices between SHN_LORESERVE  and  SHN_HIRESERVE,  inclusive;  the
                                 values  do  not  reference the section header table.  That is, the section header table does not contain entries for the reserved
                                 indices.
       An executable or shared object file's program header table is an array of structures, each describing a segment or other information the  system  needs  to
       prepare  the  program  for execution.  An object file segment contains one or more sections.  Program headers are meaningful only for executable and shared
       object files.  A file specifies its own program header size with the ELF header's e_phentsize and e_phnum members.  The ELF program header is described  by
       the type Elf32_Phdr or Elf64_Phdr depending on the architecture:
           typedef struct {
               uint32_t   p_type;
               Elf32_Off  p_offset;
               Elf32_Addr p_vaddr;
               Elf32_Addr p_paddr;
               uint32_t   p_filesz;
               uint32_t   p_memsz;
               uint32_t   p_flags;
               uint32_t   p_align;
           } Elf32_Phdr;
           typedef struct {
               uint32_t   p_type;
               uint32_t   p_flags;
               Elf64_Off  p_offset;
               Elf64_Addr p_vaddr;
               Elf64_Addr p_paddr;
               uint64_t   p_filesz;
               uint64_t   p_memsz;
               uint64_t   p_align;
           } Elf64_Phdr;
       The main difference between the 32-bit and the 64-bit program header lies in the location of the p_flags member in the total struct.
       p_type      This member of the Phdr struct tells what kind of segment this array element describes or how to interpret the array element's information.
                   PT_NULL     The array element is unused and the other members' values are undefined.  This lets the program header have ignored entries.
                   PT_LOAD     The  array  element  specifies  a  loadable  segment, described by p_filesz and p_memsz.  The bytes from the file are mapped to the
                               beginning of the memory segment.  If the segment's memory size p_memsz is larger than the file size p_filesz, the "extra" bytes are
                               defined  to  hold  the value 0 and to follow the segment's initialized area.  The file size may not be larger than the memory size.
                               Loadable segment entries in the program header table appear in ascending order, sorted on the p_vaddr member.
                   PT_DYNAMIC  The array element specifies dynamic linking information.
                   PT_INTERP   The array element specifies the location and size of a null-terminated pathname to invoke as an interpreter.  This segment type  is
                               meaningful  only for executable files (though it may occur for shared objects).  However it may not occur more than once in a file.
                               If it is present, it must precede any loadable segment entry.
                   PT_NOTE     The array element specifies the location and size for auxiliary information.
                   PT_SHLIB    This segment type is reserved but has unspecified semantics.  Programs that contain an array element of this type do not conform to
                               the ABI.
                   PT_PHDR     The array element, if present, specifies the location and size of the program header table itself, both in the file and in the memâ
                               ory image of the program.  This segment type may not occur more than once in a file.  Moreover, it may only occur  if  the  program
                               header table is part of the memory image of the program.  If it is present, it must precede any loadable segment entry.
                   PT_LOPROC   Values greater than or equal to PT_HIPROC are reserved for processor-specific semantics.
                   PT_HIPROC   Values less than or equal to PT_LOPROC are reserved for processor-specific semantics.
                   PT_GNU_STACK
                               GNU extension which is used by the Linux kernel to control the state of the stack via the flags set in the p_flags member.
       p_offset    This member holds the offset from the beginning of the file at which the first byte of the segment resides.
       p_vaddr     This member holds the virtual address at which the first byte of the segment resides in memory.
       p_paddr     On systems for which physical addressing is relevant, this member is reserved for the segment's physical address.  Under BSD this member is not
                   used and must be zero.
       p_filesz    This member holds the number of bytes in the file image of the segment.  It may be zero.
       p_memsz     This member holds the number of bytes in the memory image of the segment.  It may be zero.
       p_flags     This member holds a bitmask of flags relevant to the segment:
                   PF_X   An executable segment.
                   PF_W   A writable segment.
                   PF_R   A readable segment.
                   A text segment commonly has the flags PF_X and PF_R.  A data segment commonly has PF_X, PF_W and PF_R.
       p_align     This member holds the value to which the segments are aligned in memory and in the file.  Loadable process segments must have congruent  values
                   for  p_vaddr  and  p_offset, modulo the page size.  Values of zero and one mean no alignment is required.  Otherwise, p_align should be a posiâ
                   tive, integral power of two, and p_vaddr should equal p_offset, modulo p_align.
       A file's section header table lets one locate all the file's sections.  The section header table is an array of Elf32_Shdr or Elf64_Shdr  structures.   The
       ELF header's e_shoff member gives the byte offset from the beginning of the file to the section header table.  e_shnum holds the number of entries the secâ
       tion header table contains.  e_shentsize holds the size in bytes of each entry.
       A section header table index is a subscript into this array.  Some section header table indices are reserved: the initial entry  and  the  indices  between
       SHN_LORESERVE  and SHN_HIRESERVE.  The initial entry is used in ELF extensions for e_phnum, e_shnum and e_strndx; in other cases, each field in the initial
       entry is set to zero.  An object file does not have sections for these special indices:
              SHN_UNDEF     This value marks an undefined, missing, irrelevant or otherwise meaningless section reference.
              SHN_LORESERVE This value specifies the lower bound of the range of reserved indices.
              SHN_LOPROC    Values greater than or equal to SHN_HIPROC are reserved for processor-specific semantics.
              SHN_HIPROC    Values less than or equal to SHN_LOPROC are reserved for processor-specific semantics.
              SHN_ABS       This value specifies the absolute value for the corresponding reference.  For example, a symbol defined  relative  to  section  number
                            SHN_ABS has an absolute value and is not affected by relocation.
              SHN_COMMON    Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.
              SHN_HIRESERVE This  value  specifies  the  upper  bound  of  the  range  of reserved indices.  The system reserves indices between SHN_LORESERVE and
                            SHN_HIRESERVE, inclusive.  The section header table does not contain entries for the reserved indices.
       The section header has the following structure:
           typedef struct {
               uint32_t   sh_name;
               uint32_t   sh_type;
               uint32_t   sh_flags;
               Elf32_Addr sh_addr;
               Elf32_Off  sh_offset;
               uint32_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint32_t   sh_addralign;
               uint32_t   sh_entsize;
           } Elf32_Shdr;
           typedef struct {
               uint32_t   sh_name;
               uint32_t   sh_type;
               uint64_t   sh_flags;
               Elf64_Addr sh_addr;
               Elf64_Off  sh_offset;
               uint64_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint64_t   sh_addralign;
               uint64_t   sh_entsize;
           } Elf64_Shdr;
       No real differences exist between the 32-bit and 64-bit section headers.
       sh_name   This member specifies the name of the section.  Its value is an index into the section header string table section,  giving  the  location  of  a
                 null-terminated string.
       sh_type   This member categorizes the section's contents and semantics.
                 SHT_NULL       This  value  marks  the  section header as inactive.  It does not have an associated section.  Other members of the section header
                                have undefined values.
                 SHT_PROGBITS   This section holds information defined by the program, whose format and meaning are determined solely by the program.
                 SHT_SYMTAB     This section holds a symbol table.  Typically, SHT_SYMTAB provides symbols for link editing,  though  it  may  also  be  used  for
                                dynamic  linking.   As  a  complete symbol table, it may contain many symbols unnecessary for dynamic linking.  An object file can
                                also contain a SHT_DYNSYM section.
                 SHT_STRTAB     This section holds a string table.  An object file may have multiple string table sections.
                 SHT_RELA       This section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class  of  object  files.   An
                                object may have multiple relocation sections.
                 SHT_HASH       This  section  holds a symbol hash table.  An object participating in dynamic linking must contain a symbol hash table.  An object
                                file may have only one hash table.
                 SHT_DYNAMIC    This section holds information for dynamic linking.  An object file may have only one dynamic section.
                 SHT_NOTE       This section holds information that marks the file in some way.
                 SHT_NOBITS     A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS.   Although  this  section  contains  no
                                bytes, the sh_offset member contains the conceptual file offset.
                 SHT_REL        This  section  holds relocation offsets without explicit addends, such as type Elf32_Rel for the 32-bit class of object files.  An
                                object file may have multiple relocation sections.
                 SHT_SHLIB      This section is reserved but has unspecified semantics.
                 SHT_DYNSYM     This section holds a minimal set of dynamic linking symbols.  An object file can also contain a SHT_SYMTAB section.
                 SHT_LOPROC     This value up to and including SHT_HIPROC is reserved for processor-specific semantics.
                 SHT_HIPROC     This value down to and including SHT_LOPROC is reserved for processor-specific semantics.
                 SHT_LOUSER     This value specifies the lower bound of the range of indices reserved for application programs.
                 SHT_HIUSER     This value specifies the upper bound of the range of indices reserved for application programs.  Section types between  SHT_LOUSER
                                and SHT_HIUSER may be used by the application, without conflicting with current or future system-defined section types.
       sh_flags  Sections  support one-bit flags that describe miscellaneous attributes.  If a flag bit is set in sh_flags, the attribute is "on" for the section.
                 Otherwise, the attribute is "off" or does not apply.  Undefined attributes are set to zero.
                 SHF_WRITE      This section contains data that should be writable during process execution.
                 SHF_ALLOC      This section occupies memory during process execution.  Some control sections do not reside in the memory image of an object file.
                                This attribute is off for those sections.
                 SHF_EXECINSTR  This section contains executable machine instructions.
                 SHF_MASKPROC   All bits included in this mask are reserved for processor-specific semantics.
       sh_addr   If  this section appears in the memory image of a process, this member holds the address at which the section's first byte should reside.  Otherâ
                 wise, the member contains zero.
       sh_offset This member's value holds the byte offset from the beginning of the file to the first byte in the section.  One section type,  SHT_NOBITS,  occuâ
                 pies no space in the file, and its sh_offset member locates the conceptual placement in the file.
       sh_size   This member holds the section's size in bytes.  Unless the section type is SHT_NOBITS, the section occupies sh_size bytes in the file.  A section
                 of type SHT_NOBITS may have a nonzero size, but it occupies no space in the file.
       sh_link   This member holds a section header table index link, whose interpretation depends on the section type.
       sh_info   This member holds extra information, whose interpretation depends on the section type.
       sh_addralign
                 Some sections have address alignment constraints.  If a section holds a doubleword, the system must ensure doubleword alignment  for  the  entire
                 section.   That  is, the value of sh_addr must be congruent to zero, modulo the value of sh_addralign.  Only zero and positive integral powers of
                 two are allowed.  Values of zero or one mean the section has no alignment constraints.
       sh_entsize
                 Some sections hold a table of fixed-sized entries, such as a symbol table.  For such a section, this member gives the  size  in  bytes  for  each
                 entry.  This member contains zero if the section does not hold a table of fixed-size entries.
       Various sections hold program and control information:
       sh_info   This member holds extra information, whose interpretation depends on the section type.
       sh_addralign
                 Some sections have address alignment constraints.  If a section holds a doubleword, the system must ensure doubleword alignment  for  the  entire
                 section.   That  is, the value of sh_addr must be congruent to zero, modulo the value of sh_addralign.  Only zero and positive integral powers of
                 SHT_SHLIB      This section is reserved but has unspecified semantics.
                 SHT_DYNSYM     This section holds a minimal set of dynamic linking symbols.  An object file can also contain a SHT_SYMTAB section.
                 SHT_LOPROC     This value up to and including SHT_HIPROC is reserved for processor-specific semantics.
                 SHT_HIPROC     This value down to and including SHT_LOPROC is reserved for processor-specific semantics.
                 SHT_LOUSER     This value specifies the lower bound of the range of indices reserved for application programs.
                 SHT_HIUSER     This value specifies the upper bound of the range of indices reserved for application programs.  Section types between  SHT_LOUSER
                                and SHT_HIUSER may be used by the application, without conflicting with current or future system-defined section types.
       sh_flags  Sections  support one-bit flags that describe miscellaneous attributes.  If a flag bit is set in sh_flags, the attribute is "on" for the section.
                 Otherwise, the attribute is "off" or does not apply.  Undefined attributes are set to zero.
                 SHF_WRITE      This section contains data that should be writable during process execution.
                 SHF_ALLOC      This section occupies memory during process execution.  Some control sections do not reside in the memory image of an object file.
                                This attribute is off for those sections.
               uint32_t   sh_type;
               uint32_t   sh_flags;
               Elf32_Addr sh_addr;
               Elf32_Off  sh_offset;
               uint32_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint32_t   sh_addralign;
               uint32_t   sh_entsize;
           } Elf32_Shdr;
                   for  p_vaddr  and  p_offset, modulo the page size.  Values of zero and one mean no alignment is required.  Otherwise, p_align should be a posiâ
                   tive, integral power of two, and p_vaddr should equal p_offset, modulo p_align.
       A file's section header table lets one locate all the file's sections.  The section header table is an array of Elf32_Shdr or Elf64_Shdr  structures.   The
       ELF header's e_shoff member gives the byte offset from the beginning of the file to the section header table.  e_shnum holds the number of entries the secâ
       tion header table contains.  e_shentsize holds the size in bytes of each entry.
       A section header table index is a subscript into this array.  Some section header table indices are reserved: the initial entry  and  the  indices  between
       SHN_LORESERVE  and SHN_HIRESERVE.  The initial entry is used in ELF extensions for e_phnum, e_shnum and e_strndx; in other cases, each field in the initial
       entry is set to zero.  An object file does not have sections for these special indices:
              SHN_UNDEF     This value marks an undefined, missing, irrelevant or otherwise meaningless section reference.
              SHN_LORESERVE This value specifies the lower bound of the range of reserved indices.
              SHN_LOPROC    Values greater than or equal to SHN_HIPROC are reserved for processor-specific semantics.
              SHN_HIPROC    Values less than or equal to SHN_LOPROC are reserved for processor-specific semantics.
              SHN_ABS       This value specifies the absolute value for the corresponding reference.  For example, a symbol defined  relative  to  section  number
                            SHN_ABS has an absolute value and is not affected by relocation.
              SHN_COMMON    Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.
              SHN_HIRESERVE This  value  specifies  the  upper  bound  of  the  range  of reserved indices.  The system reserves indices between SHN_LORESERVE and
                            SHN_HIRESERVE, inclusive.  The section header table does not contain entries for the reserved indices.
       The section header has the following structure:
           typedef struct {
               uint32_t   sh_name;
               uint32_t   sh_type;
               uint32_t   sh_flags;
               Elf32_Addr sh_addr;
               Elf32_Off  sh_offset;
               Elf32_Off  sh_offset;
               uint32_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint32_t   sh_addralign;
               uint32_t   sh_entsize;
           } Elf32_Shdr;
           typedef struct {
               uint32_t   sh_name;
               uint32_t   sh_type;
               uint64_t   sh_flags;
               Elf64_Addr sh_addr;
               Elf64_Off  sh_offset;
               uint64_t   sh_size;
               uint32_t   sh_link;
               uint32_t   sh_info;
               uint64_t   sh_addralign;
               uint64_t   sh_entsize;
           } Elf64_Shdr;
       No real differences exist between the 32-bit and 64-bit section headers.
       sh_name   This member specifies the name of the section.  Its value is an index into the section header string table section,  giving  the  location  of  a
                 null-terminated string.
       sh_type   This member categorizes the section's contents and semantics.
                 SHT_NULL       This  value  marks  the  section header as inactive.  It does not have an associated section.  Other members of the section header
                                have undefined values.
                 SHT_PROGBITS   This section holds information defined by the program, whose format and meaning are determined solely by the program.
                 SHT_SYMTAB     This section holds a symbol table.  Typically, SHT_SYMTAB provides symbols for link editing,  though  it  may  also  be  used  for
                                dynamic  linking.   As  a  complete symbol table, it may contain many symbols unnecessary for dynamic linking.  An object file can
                                also contain a SHT_DYNSYM section.
                 SHT_STRTAB     This section holds a string table.  An object file may have multiple string table sections.
                 SHT_RELA       This section holds relocation entries with explicit addends, such as type Elf32_Rela for the 32-bit class  of  object  files.   An
                                object may have multiple relocation sections.
                 SHT_HASH       This  section  holds a symbol hash table.  An object participating in dynamic linking must contain a symbol hash table.  An object
                                file may have only one hash table.
                 SHT_DYNAMIC    This section holds information for dynamic linking.  An object file may have only one dynamic section.
                 SHT_NOTE       This section holds information that marks the file in some way.
                 SHT_NOBITS     A section of this type occupies no space in the file but otherwise resembles SHT_PROGBITS.   Although  this  section  contains  no
                                bytes, the sh_offset member contains the conceptual file offset.
                 SHT_REL        This  section  holds relocation offsets without explicit addends, such as type Elf32_Rel for the 32-bit class of object files.  An
                                object file may have multiple relocation sections.
                 SHT_SHLIB      This section is reserved but has unspecified semantics.
                 SHT_DYNSYM     This section holds a minimal set of dynamic linking symbols.  An object file can also contain a SHT_SYMTAB section.
                 SHT_LOPROC     This value up to and including SHT_HIPROC is reserved for processor-specific semantics.
                 SHT_HIPROC     This value down to and including SHT_LOPROC is reserved for processor-specific semantics.
                 SHT_LOUSER     This value specifies the lower bound of the range of indices reserved for application programs.
                 SHT_HIUSER     This value specifies the upper bound of the range of indices reserved for application programs.  Section types between  SHT_LOUSER
                                and SHT_HIUSER may be used by the application, without conflicting with current or future system-defined section types.
       sh_flags  Sections  support one-bit flags that describe miscellaneous attributes.  If a flag bit is set in sh_flags, the attribute is "on" for the section.
                 Otherwise, the attribute is "off" or does not apply.  Undefined attributes are set to zero.
                 SHF_WRITE      This section contains data that should be writable during process execution.
                 SHF_ALLOC      This section occupies memory during process execution.  Some control sections do not reside in the memory image of an object file.
                                This attribute is off for those sections.
                 SHF_EXECINSTR  This section contains executable machine instructions.
                 SHF_MASKPROC   All bits included in this mask are reserved for processor-specific semantics.
       sh_addr   If  this section appears in the memory image of a process, this member holds the address at which the section's first byte should reside.  Otherâ
                 wise, the member contains zero.
       sh_offset This member's value holds the byte offset from the beginning of the file to the first byte in the section.  One section type,  SHT_NOBITS,  occuâ
                 pies no space in the file, and its sh_offset member locates the conceptual placement in the file.
       sh_size   This member holds the section's size in bytes.  Unless the section type is SHT_NOBITS, the section occupies sh_size bytes in the file.  A section
                 of type SHT_NOBITS may have a nonzero size, but it occupies no space in the file.
       sh_link   This member holds a section header table index link, whose interpretation depends on the section type.
       sh_info   This member holds extra information, whose interpretation depends on the section type.
       sh_addralign
                 Some sections have address alignment constraints.  If a section holds a doubleword, the system must ensure doubleword alignment  for  the  entire
                 section.   That  is, the value of sh_addr must be congruent to zero, modulo the value of sh_addralign.  Only zero and positive integral powers of
                 two are allowed.  Values of zero or one mean the section has no alignment constraints.
       sh_entsize
                 Some sections hold a table of fixed-sized entries, such as a symbol table.  For such a section, this member gives the  size  in  bytes  for  each
                 entry.  This member contains zero if the section does not hold a table of fixed-size entries.
       Various sections hold program and control information:
       .bss      This  section holds uninitialized data that contributes to the program's memory image.  By definition, the system initializes the data with zeros
                 when the program begins to run.  This section is of type SHT_NOBITS.  The attribute types are SHF_ALLOC and SHF_WRITE.
       .comment  This section holds version control information.  This section is of type SHT_PROGBITS.  No attribute types are used.
       .ctors    This section holds initialized pointers to the C++ constructor functions.  This section  is  of  type  SHT_PROGBITS.   The  attribute  types  are
                 SHF_ALLOC and SHF_WRITE.
       .data     This  section  holds  initialized data that contribute to the program's memory image.  This section is of type SHT_PROGBITS.  The attribute types
                 are SHF_ALLOC and SHF_WRITE.
       .data1    This section holds initialized data that contribute to the program's memory image.  This section is of type SHT_PROGBITS.   The  attribute  types
                 are SHF_ALLOC and SHF_WRITE.
       .debug    This  section holds information for symbolic debugging.  The contents are unspecified.  This section is of type SHT_PROGBITS.  No attribute types
                 are used.
       .dtors    This section holds initialized pointers to the C++ destructor functions.  This  section  is  of  type  SHT_PROGBITS.   The  attribute  types  are
                 SHF_ALLOC and SHF_WRITE.
       .dynamic  This  section  holds  dynamic linking information.  The section's attributes will include the SHF_ALLOC bit.  Whether the SHF_WRITE bit is set is
                 processor-specific.  This section is of type SHT_DYNAMIC.  See the attributes above.
       .dynstr   This section holds strings needed for dynamic linking, most commonly the strings that represent the names associated with symbol  table  entries.
                 This section is of type SHT_STRTAB.  The attribute type used is SHF_ALLOC.
       .dynsym   This section holds the dynamic linking symbol table.  This section is of type SHT_DYNSYM.  The attribute used is SHF_ALLOC.
       .fini     This section holds executable instructions that contribute to the process termination code.  When a program exits normally the system arranges to
                 execute the code in this section.  This section is of type SHT_PROGBITS.  The attributes used are SHF_ALLOC and SHF_EXECINSTR.
       .gnu.version
                 This section holds the version symbol table, an array of ElfN_Half elements.  This section is of type SHT_GNU_versym.  The attribute type used is
                 SHF_ALLOC.
       .gnu.version_d
                 This  section  holds  the  version symbol definitions, a table of ElfN_Verdef structures.  This section is of type SHT_GNU_verdef.  The attribute
                 type used is SHF_ALLOC.
       .gnu.version_r
                 This section holds the version symbol needed elements, a table of  ElfN_Verneed  structures.   This  section  is  of  type  SHT_GNU_versym.   The
                 attribute type used is SHF_ALLOC.
       .got      This section holds the global offset table.  This section is of type SHT_PROGBITS.  The attributes are processor specific.
       .hash     This section holds a symbol hash table.  This section is of type SHT_HASH.  The attribute used is SHF_ALLOC.
       .init     This  section holds executable instructions that contribute to the process initialization code.  When a program starts to run the system arranges
                 to execute the code in this section before calling the main program entry point.  This section is of type SHT_PROGBITS.  The attributes used  are
                 SHF_ALLOC and SHF_EXECINSTR.
       .interp   This section holds the pathname of a program interpreter.  If the file has a loadable segment that includes the section, the section's attributes
                 will include the SHF_ALLOC bit.  Otherwise, that bit will be off.  This section is of type SHT_PROGBITS.
       .line     This section holds line number information for symbolic debugging, which describes the correspondence between the program source and the  machine
                 code.  The contents are unspecified.  This section is of type SHT_PROGBITS.  No attribute types are used.
       .note     This  section  holds  information  in the "Note Section" format.  This section is of type SHT_NOTE.  No attribute types are used.  OpenBSD native
                 executables usually contain a .note.openbsd.ident section to identify themselves, for the kernel to bypass any compatibility ELF binary emulation
                 tests when loading the file.
       .note.GNU-stack
                 This  section  is  used  in Linux object files for declaring stack attributes.  This section is of type SHT_PROGBITS.  The only attribute used is
                 SHF_EXECINSTR.  This indicates to the GNU linker that the object file requires an executable stack.
       .plt      This section holds the procedure linkage table.  This section is of type SHT_PROGBITS.  The attributes are processor specific.
       .relNAME  This section holds relocation information as described below.  If the file has  a  loadable  segment  that  includes  relocation,  the  section's
                 attributes will include the SHF_ALLOC bit.  Otherwise the bit will be off.  By convention, "NAME" is supplied by the section to which the relocaâ
                 tions apply.  Thus a relocation section for .text normally would have the name .rel.text.  This section is of type SHT_REL.
       .relaNAME This section holds relocation information as described below.  If the file has  a  loadable  segment  that  includes  relocation,  the  section's
                 attributes will include the SHF_ALLOC bit.  Otherwise the bit will be off.  By convention, "NAME" is supplied by the section to which the relocaâ
                 tions apply.  Thus a relocation section for .text normally would have the name .rela.text.  This section is of type SHT_RELA.
       .rodata   This section holds read-only data that typically contributes to a nonwritable segment in the process image.  This section is  of  type  SHT_PROGâ
                 BITS.  The attribute used is SHF_ALLOC.
       .rodata1  This  section  holds  read-only data that typically contributes to a nonwritable segment in the process image.  This section is of type SHT_PROGâ
                 BITS.  The attribute used is SHF_ALLOC.
       .shstrtab This section holds section names.  This section is of type SHT_STRTAB.  No attribute types are used.
       .strtab   This section holds strings, most commonly the strings that represent the names associated with symbol table entries.  If the file has a  loadable
                 segment  that  includes  the  symbol string table, the section's attributes will include the SHF_ALLOC bit.  Otherwise the bit will be off.  This
                 section is of type SHT_STRTAB.
       .symtab   This section holds a symbol table.  If the file has a loadable segment that includes the symbol table, the section's attributes will include  the
                 SHF_ALLOC bit.  Otherwise the bit will be off.  This section is of type SHT_SYMTAB.
       .text     This  section  holds  the  "text",  or  executable  instructions,  of  a program.  This section is of type SHT_PROGBITS.  The attributes used are
                 SHF_ALLOC and SHF_EXECINSTR.
       String table sections hold null-terminated character sequences, commonly called strings.  The object file uses these strings to represent symbol  and  secâ
       tion  names.   One  references  a  string  as  an index into the string table section.  The first byte, which is index zero, is defined to hold a null byte
       (' ').  Similarly, a string table's last byte is defined to hold a null byte, ensuring null termination for all strings.
       An object file's symbol table holds information needed to locate and relocate a program's symbolic definitions and references.  A symbol table index  is  a
       subscript into this array.
           typedef struct {
               uint32_t      st_name;
               Elf32_Addr    st_value;
               uint32_t      st_size;
               unsigned char st_info;
               unsigned char st_other;
               uint16_t      st_shndx;
           } Elf32_Sym;
           typedef struct {
               uint32_t      st_name;
               unsigned char st_info;
               unsigned char st_other;
               uint16_t      st_shndx;
               Elf64_Addr    st_value;
               uint64_t      st_size;
           } Elf64_Sym;
       The 32-bit and 64-bit versions have the same members, just in a different order.
       st_name   This  member  holds an index into the object file's symbol string table, which holds character representations of the symbol names.  If the value
                 is nonzero, it represents a string table index that gives the symbol name.  Otherwise, the symbol table has no name.
       st_value  This member gives the value of the associated symbol.
       st_size   Many symbols have associated sizes.  This member holds zero if the symbol has no size or an unknown size.
       st_info   This member specifies the symbol's type and binding attributes:
                 STT_NOTYPE  The symbol's type is not defined.
                 STT_OBJECT  The symbol is associated with a data object.
                 STT_FUNC    The symbol is associated with a function or other executable code.
                 STT_SECTION The symbol is associated with a section.  Symbol table entries of  this  type  exist  primarily  for  relocation  and  normally  have
                             STB_LOCAL bindings.
                 STT_FILE    By  convention,  the  symbol's  name  gives the name of the source file associated with the object file.  A file symbol has STB_LOCAL
                             bindings, its section index is SHN_ABS, and it precedes the other STB_LOCAL symbols of the file, if it is present.
                 STT_LOPROC  This value up to and including STT_HIPROC is reserved for processor-specific semantics.
                 STT_HIPROC  This value down to and including STT_LOPROC is reserved for processor-specific semantics.
                 STB_LOCAL   Local symbols are not visible outside the object file containing their definition.  Local symbols of the same name may exist in  mulâ
                             tiple files without interfering with each other.
                 STB_GLOBAL  Global  symbols are visible to all object files being combined.  One file's definition of a global symbol will satisfy another file's
                             undefined reference to the same symbol.
                 STB_WEAK    Weak symbols resemble global symbols, but their definitions have lower precedence.
                 STB_LOPROC  This value up to and including STB_HIPROC is reserved for processor-specific semantics.
                 STB_HIPROC  This value down to and including STB_LOPROC is reserved for processor-specific semantics.
                             There are macros for packing and unpacking the binding and type fields:
                             ELF32_ST_BIND(info) or ELF64_ST_BIND(info) extract a binding from an st_info value.
                             ELF32_ST_TYPE(info) or ELF64_ST_TYPE(info)
                             extract a type from an st_info value.
                             ELF32_ST_INFO(bind, type) or ELF64_ST_INFO(bind, type)
                             convert a binding and a type into an st_info value.
       st_other  This member defines the symbol visibility.
                 STV_DEFAULT     Default symbol visibility rules.
                 STV_INTERNAL    Processor-specific hidden class.
                 STV_HIDDEN      Symbol is unavailable in other modules.
                 STV_PROTECTED   Not preemptible, not exported.
                 There are macros for extracting the visibility type:
                 ELF32_ST_VISIBILITY(other) or ELF64_ST_VISIBILITY(other)
       st_shndx  Every symbol table entry is "defined" in relation to some section.  This member holds the relevant section header table index.
       Relocation is the process of connecting symbolic references with symbolic definitions.  Relocatable files must have information that describes how to  modâ
       ify  their  section  contents,  thus  allowing  executable and shared object files to hold the right information for a process's program image.  Relocation
       entries are these data.
       Relocation structures that do not need an addend:
           typedef struct {
               Elf32_Addr r_offset;
               uint32_t   r_info;
           } Elf32_Rel;
           typedef struct {
               Elf64_Addr r_offset;
               uint64_t   r_info;
           } Elf64_Rel;
       Relocation structures that need an addend:
           typedef struct {
               Elf32_Addr r_offset;
               uint32_t   r_info;
               int32_t    r_addend;
           } Elf32_Rela;
           typedef struct {
               Elf64_Addr r_offset;
               uint64_t   r_info;
               int64_t    r_addend;
           } Elf64_Rela;
       r_offset    This member gives the location at which to apply the relocation action.  For a relocatable file, the value is the byte offset from  the  beginâ
                   ning  of the section to the storage unit affected by the relocation.  For an executable file or shared object, the value is the virtual address
                   of the storage unit affected by the relocation.
       r_info      This member gives both the symbol table index with respect to which the relocation must be made and the type of relocation to  apply.   Relocaâ
                   tion  types are processor specific.  When the text refers to a relocation entry's relocation type or symbol table index, it means the result of
                   applying ELF[32|64]_R_TYPE or ELF[32|64]_R_SYM, respectively, to the entry's r_info member.
       r_addend    This member specifies a constant addend used to compute the value to be stored into the relocatable field.
       The .dynamic section contains a series of structures that hold relevant dynamic linking information.  The d_tag member controls the interpretation of d_un.
           typedef struct {
               Elf32_Sword    d_tag;
               union {
                   Elf32_Word d_val;
                   Elf32_Addr d_ptr;
               } d_un;
           } Elf32_Dyn;
           extern Elf32_Dyn _DYNAMIC[];
           typedef struct {
               Elf64_Sxword    d_tag;
               union {
                   Elf64_Xword d_val;
                   Elf64_Addr  d_ptr;
               } d_un;
           } Elf64_Dyn;
           extern Elf64_Dyn _DYNAMIC[];
       d_tag     This member may have any of the following values:
                 DT_NULL     Marks end of dynamic section
                 DT_NEEDED   String table offset to name of a needed library
                 DT_PLTRELSZ Size in bytes of PLT relocs
                 DT_PLTGOT   Address of PLT and/or GOT
                 DT_HASH     Address of symbol hash table
                 DT_STRTAB   Address of string table
                 DT_SYMTAB   Address of symbol table
                 DT_RELA     Address of Rela relocs table
                 DT_RELASZ   Size in bytes of Rela table
                 DT_RELAENT  Size in bytes of a Rela table entry
                 DT_STRSZ    Size in bytes of string table
                 DT_SYMENT   Size in bytes of a symbol table entry
                 DT_INIT     Address of the initialization function
                 DT_FINI     Address of the termination function
                 DT_SONAME   String table offset to name of shared object
                 DT_RPATH    String table offset to library search path (deprecated)
                 DT_SYMBOLIC Alert linker to search this shared object before the executable for symbols
                 DT_REL      Address of Rel relocs table
                 DT_RELSZ    Size in bytes of Rel table
                 DT_RELENT   Size in bytes of a Rel table entry
                 DT_PLTREL   Type of reloc the PLT refers (Rela or Rel)
                 DT_DEBUG    Undefined use for debugging
                 DT_TEXTREL  Absence of this indicates no relocs should apply to a nonwritable segment
                 DT_JMPREL   Address of reloc entries solely for the PLT
                 DT_BIND_NOW Instruct dynamic linker to process all relocs before transferring control to the executable
                 DT_RUNPATH  String table offset to library search path
                 DT_LOPROC   Start of processor-specific semantics
                 DT_HIPROC   End of processor-specific semantics
       d_val     This member represents integer values with various interpretations.
       d_ptr     This member represents program virtual addresses.  When interpreting these addresses, the actual address should be computed based on the original
                 file value and memory base address.  Files do not contain relocation entries to fixup these addresses.
       _DYNAMIC  Array containing all the dynamic structures in the .dynamic section.  This is automatically populated by the linker.
NOTES
       ELF first appeared in System V.  The ELF format is an adopted standard.
       The  extensions  for  e_phnum, e_shnum and e_strndx respectively are Linux extensions.  Sun, BSD and AMD64 also support them; for further information, look
       under SEE ALSO.
SEE ALSO
       as(1), gdb(1), ld(1), objdump(1), execve(2), core(5)
```
# tmpfs
tmpfsæ¯åå­æä»¶ç³»ç»ã
# å»ºç«ä¸ä¸ªåå­æä»¶ç³»ç»
```sh
$ mkdir /tmp/shm
$ sudo mount tmpfs /tmp/shm  -t tmpfs
$ cd /tmp/shm
$ echo hello > hello.txt ; ls 
hello.txt
```
# å»¶é¿Sdå¡çä½¿ç¨å¯¿å½
These methods should increase the lifespan of the SD card by minimising the number of read/writes in various ways:
Disable Swap
Swapping is the process of using part of the SD card as volatile memory. This will increase the amount of RAM available, but it will result in a high number of read/writes. It is unlikely to increase performance significantly.
Disable swap with the swapoff command:
sudo swapoff --all
You must also prevent it from coming back after a reboot:
For Raspbian which uses dphys-swapfile to manage a swap file (instead of a "normal" swap partition) you can simply sudo apt-get remove dphys-swapfile to remove it permanently. Best to remove because setting the CONF_SWAPSIZE to 0, as explained in this answer, doesn't seem to work and still creates a 100MB swap file after reboot.
For other distributions that use a swap partition instead of a swap file, remove the appropriate line from /etc/fstab
Disabling Journaling on the Filesystem
Using a journaling filesystem such as ext3 or ext4 WITHOUT a journal is an option to decrease read/writes. The obvious drawback of using a filesystem with journaling disabled is data loss as a result of an ungraceful dismount (i.e. post power failure, kernel lockup, etc.).
You can disable journaling on ext3 by mounting it as ext2.
You can disable journaling on ext4 on an unmounted drive like this:
tune4fs -O ^has_journal /dev/sdaX
e4fsck âf /dev/sdaX
sudo reboot
The noatime Mount Flag
Assign the noatime mount flag to partitions residing on the SD card by adding it to the options section of the partition in /etc/fstab.
Reading accesses to the file system will no longer result in an update to the atime information associated with the file. The importance of the noatime setting is that it eliminates the need by the system to make writes to the file system for files which are simply being read. Since writes can be somewhat expensive as mentioned in previous section, this can result in measurable performance gains. Note that the write time information to a file will continue to be updated anytime the file is written to with this option enabled.
Directories in RAM
Highly used directories such as /var/tmp/ and possibly /var/log can be relocated to RAM in /etc/fstab like this:
tmpfs /var/tmp tmpfs nodev,nosuid,size=50M 0 0
This will allow /var/tmp to use 50MB of RAM as disk space. The only issue with doing this is that any drives mounted in RAM will not persist past a reboot. Thus if you mount /var/log and your system encounters an error that causes it to reboot, you will not be able to find out why.
Directories in external Hard Disk
You can also mount some directories on a persistent USB hard disk. More details of this can be found in this question.
The Raspberry Pi can also boot it's root partition from an external drive. This could be via USB or Ethernet and means that the SD card will only be used to delegate to different device during boot. This requires a bit of kernel hacking to accomplish, as I don't think the default kernel supports USB storage. You can find more information at this question, or this external blog post.
If the options provided by Jivings aren't possible for your application then another option to extend it's life substantially is to use an SD card which is much bigger than you need.
Leave plenty of free space
Most decent SD cards use wear levelling algorithms to minimise the number of times each block is written, so if the SD card is bigger than you need the wear can be spread over a much larger area of free space.
Part of the reason wear levelling is so important is that some file systems, such as FAT (the default format for many SD cards), hammer the same sectors over and over again.
For more information on this, see the answers to the question Is it true that a SD/MMC Card does wear levelling with its own controller? over on Electronics Stack Exchange, especially this answer.
One interesting statistic from this answer is that
taking a 2GB card and writing it beginning to end over and over again averages about 10TB before the card is dead and no longer is writable.
But the worrying thing is that
SD cards will not let you know when data is bad, i.e. wont return an I/O error like a PC harddrive will.
This may make your choice of file system important if you need to guarantee reliable storage.
One final note: Doubling the size of the SD card could more than double the longevity of it.
I.e. if you have a 2 GB SD card with 200 MB free then switching to a 4 GB card will give you 11 times the free space, wear levelling capacity and thus longevity, while switching to a 16 GB card will give you 71 times the free space.
```
I work for a company that used to be a member of the SD association, we are familiar with the 2.0 (SDHC) spec. The SD card spec has NO entry for wear leveling. That is completely dependent on the SD manufacturer to handle that if they so choose. We have seen that some likely do, while others very much do not (beware the super cheap knock-off SD cards). SDXC may have changed that to include wear leveling, but I am unsure of that. Unfortunately the only way to really show that is to get your hands on the official spec. You can find it online most likely, but the SD association really wants you to pay for it.
As a side note, taking a 2GB card and writing it beginning to end over and over again averages about 10TB before the card is dead and no longer is writable. Also, SD cards will not let you know when data is bad, i.e. wont return an I/O error like a PC harddrive will. This might not be an issue for embedded designs as 10TB is a LOT of data, but it could be a factor for someone.
```
```
NORåNAND Flashå­å¨å¨çåºå«
NORåNANDæ¯ç°å¨å¸åºä¸ä¸¤ç§ä¸»è¦çéæå¤±éªå­ææ¯ãInteläº1988å¹´é¦åå¼ååºNOR flashææ¯,å½»åºæ¹åäºååç±EPROMåEEPROMä¸ç»å¤©ä¸çå±é¢ãç´§æ¥ç,1989å¹´,ä¸èå¬å¸åè¡¨äºNAND flashç»æ,å¼ºè°éä½æ¯æ¯ç¹çææ¬,æ´é«çæ§è½,å¹¶ä¸è±¡ç£çä¸æ ·å¯ä»¥éè¿æ¥å£è½»æ¾åçº§ãä½æ¯ç»è¿äºåå¤å¹´ä¹å,ä»ç¶æç¸å½å¤çç¡¬ä»¶å·¥ç¨å¸åä¸æ¸NORåNANDéªå­ã
ããç¸âflashå­å¨å¨âç»å¸¸å¯ä»¥ä¸ç¸âNORå­å¨å¨âäºæ¢ä½¿ç¨ãè®¸å¤ä¸åäººå£«ä¹æä¸æ¸æ¥NANDéªå­ææ¯ç¸å¯¹äºNORææ¯çä¼è¶ä¹å¤,å ä¸ºå¤§å¤æ°æåµä¸éªå­åªæ¯ç¨æ¥å­å¨å°éçä»£ç ,è¿æ¶NORéªå­æ´éåä¸äºãèNANDåæ¯é«æ°æ®å­å¨å¯åº¦ççæ³è§£å³æ¹æ¡ã
ããNORçç¹ç¹æ¯è¯çåæ§è¡(XIP, eXecute In Place),è¿æ ·åºç¨ç¨åºå¯ä»¥ç´æ¥å¨flashéªå­åè¿è¡,ä¸å¿åæä»£ç è¯»å°ç³»ç»RAMä¸­ã
NORçä¼ è¾æçå¾é«,å¨1ï½4MBçå°å®¹éæ¶å·æå¾é«çææ¬æç,ä½æ¯å¾ä½çåå¥åæ¦é¤éåº¦å¤§å¤§å½±åäºå®çæ§è½ã
ããNANDç»æè½æä¾æé«çååå¯åº¦,å¯ä»¥è¾¾å°é«å­å¨å¯åº¦,å¹¶ä¸åå¥åæ¦é¤çéåº¦ä¹å¾å¿«ãåºç¨NANDçå°é¾å¨äºflashçç®¡çåéè¦ç¹æ®çç³»ç»æ¥å£ã
 
æ§è½æ¯è¾
ããflashéªå­æ¯éæå¤±å­å¨å¨,å¯ä»¥å¯¹ç§°ä¸ºåçå­å¨å¨åååè¿è¡æ¦åååç¼ç¨ãä»»ä½flashå¨ä»¶çåå¥æä½åªè½å¨ç©ºæå·²æ¦é¤çåååè¿è¡,æä»¥å¤§å¤æ°æåµä¸,å¨è¿è¡åå¥æä½ä¹åå¿é¡»åæ§è¡æ¦é¤ãNANDå¨ä»¶æ§è¡æ¦é¤æä½æ¯ååç®åç,èNORåè¦æ±å¨è¿è¡æ¦é¤ååè¦å°ç®æ ååææçä½é½åä¸º0ã
ããç±äºæ¦é¤NORå¨ä»¶æ¶æ¯ä»¥64ï½128KBçåè¿è¡ç,æ§è¡ä¸ä¸ªåå¥/æ¦é¤æä½çæ¶é´ä¸º5s,ä¸æ­¤ç¸å,æ¦é¤NANDå¨ä»¶æ¯ä»¥8ï½32KBçåè¿è¡ç,æ§è¡ç¸åçæä½æå¤åªéè¦4msã
ããæ§è¡æ¦é¤æ¶åå°ºå¯¸çä¸åè¿ä¸æ­¥æå¤§äºNORåNADNä¹é´çæ§è½å·®è·,ç»è®¡è¡¨æ,å¯¹äºç»å®çä¸å¥åå¥æä½(å°¤å¶æ¯æ´æ°å°æä»¶æ¶æ´å¤çæ¦é¤æä½å¿é¡»å¨åºäºNORçååä¸­è¿è¡ãè¿æ ·,å½éæ©å­å¨è§£å³æ¹æ¡æ¶,è®¾è®¡å¸å¿é¡»æè¡¡ä»¥ä¸çåé¡¹å ç´ ã
ããâ NORçè¯»éåº¦æ¯NANDç¨å¿«ä¸äºã
ããâ NANDçåå¥éåº¦æ¯NORå¿«å¾å¤ã
ããâ NANDç4msæ¦é¤éåº¦è¿æ¯NORç5så¿«ã
ããâ å¤§å¤æ°åå¥æä½éè¦åè¿è¡æ¦é¤æä½ã
ããâ NANDçæ¦é¤ååæ´å°,ç¸åºçæ¦é¤çµè·¯æ´å°ã
 
æ¥å£å·®å«
ããNOR flashå¸¦æSRAMæ¥å£,æè¶³å¤çå°åå¼èæ¥å¯»å,å¯ä»¥å¾å®¹æå°å­åå¶åé¨çæ¯ä¸ä¸ªå­èã
ããNANDå¨ä»¶ä½¿ç¨å¤æçI/Oå£æ¥ä¸²è¡å°å­åæ°æ®,åä¸ªäº§åæååçæ¹æ³å¯è½åä¸ç¸åã8ä¸ªå¼èç¨æ¥ä¼ éæ§å¶ãå°ååæ°æ®ä¿¡æ¯ã
ããNANDè¯»ååæä½éç¨512å­èçå,è¿ä¸ç¹æç¹åç¡¬çç®¡çæ­¤ç±»æä½,å¾èªç¶å°,åºäºNANDçå­å¨å¨å°±å¯ä»¥åä»£ç¡¬çæå¶ä»åè®¾å¤ã
 
å®¹éåææ¬
ããNAND flashçååå°ºå¯¸å ä¹æ¯NORå¨ä»¶çä¸å,ç±äºçäº§è¿ç¨æ´ä¸ºç®å,NANDç»æå¯ä»¥å¨ç»å®çæ¨¡å·å°ºå¯¸åæä¾æ´é«çå®¹é,ä¹å°±ç¸åºå°éä½äºä»·æ ¼ã
ããNOR flashå æ®äºå®¹éä¸º1ï½16MBéªå­å¸åºçå¤§é¨å,èNAND flashåªæ¯ç¨å¨8ï½128MBçäº§åå½ä¸­,è¿ä¹è¯´æNORä¸»è¦åºç¨å¨ä»£ç å­å¨ä»è´¨ä¸­,NANDéåäºæ°æ®å­å¨,NANDå¨CompactFlashãSecure DigitalãPC CardsåMMCå­å¨å¡å¸åºä¸æå ä»½é¢æå¤§ã
 
å¯é æ§åèç¨æ§
ããéç¨flahsä»è´¨æ¶ä¸ä¸ªéè¦éç¹èèçé®é¢æ¯å¯é æ§ãå¯¹äºéè¦æ©å±MTBFçç³»ç»æ¥è¯´,Flashæ¯éå¸¸åéçå­å¨æ¹æ¡ãå¯ä»¥ä»å¯¿å½(èç¨æ§)ãä½äº¤æ¢åååå¤çä¸ä¸ªæ¹é¢æ¥æ¯è¾NORåNANDçå¯é æ§ã
ããå¯¿å½(èç¨æ§)
ããå¨NANDéªå­ä¸­æ¯ä¸ªåçæå¤§æ¦åæ¬¡æ°æ¯ä¸ç¾ä¸æ¬¡,èNORçæ¦åæ¬¡æ°æ¯åä¸æ¬¡ãNANDå­å¨å¨é¤äºå·æ10æ¯1çåæ¦é¤å¨æä¼å¿,å¸åçNANDåå°ºå¯¸è¦æ¯NORå¨ä»¶å°8å,æ¯ä¸ªNANDå­å¨å¨åå¨ç»å®çæ¶é´åçå é¤æ¬¡æ°è¦å°ä¸äºã
ããä½äº¤æ¢
ããææflashå¨ä»¶é½åä½äº¤æ¢ç°è±¡çå°æ°ãå¨æäºæåµä¸(å¾å°è§,NANDåççæ¬¡æ°è¦æ¯NORå¤),ä¸ä¸ªæ¯ç¹ä½ä¼åçåè½¬æè¢«æ¥ååè½¬äºã
ããä¸ä½çååå¯è½ä¸å¾ææ¾,ä½æ¯å¦æåçå¨ä¸ä¸ªå³é®æä»¶ä¸,è¿ä¸ªå°å°çæéå¯è½å¯¼è´ç³»ç»åæºãå¦æåªæ¯æ¥åæé®é¢,å¤è¯»å æ¬¡å°±å¯è½è§£å³äºã
ããå½ç¶,å¦æè¿ä¸ªä½ççæ¹åäº,å°±å¿é¡»éç¨éè¯¯æ¢æµ/éè¯¯æ´æ­£(EDC/ECC)ç®æ³ãä½åè½¬çé®é¢æ´å¤è§äºNANDéªå­,NANDçä¾åºåå»ºè®®ä½¿ç¨NANDéªå­çæ¶å,åæ¶ä½¿ç¨EDC/ECCç®æ³ã
ããè¿ä¸ªé®é¢å¯¹äºç¨NANDå­å¨å¤åªä½ä¿¡æ¯æ¶åä¸æ¯è´å½çãå½ç¶,å¦æç¨æ¬å°å­å¨è®¾å¤æ¥å­å¨æä½ç³»ç»ãéç½®æä»¶æå¶ä»ææä¿¡æ¯æ¶,å¿é¡»ä½¿ç¨EDC/ECCç³»ç»ä»¥ç¡®ä¿å¯é æ§ã
ããååå¤ç
ããNANDå¨ä»¶ä¸­çååæ¯éæºåå¸çãä»¥åä¹æ¾æè¿æ¶é¤ååçåªå,ä½åç°æåçå¤ªä½,ä»£ä»·å¤ªé«,æ ¹æ¬ä¸åç®ã
ããNANDå¨ä»¶éè¦å¯¹ä»è´¨è¿è¡åå§åæ«æä»¥åç°åå,å¹¶å°ååæ è®°ä¸ºä¸å¯ç¨ãå¨å·²å¶æçå¨ä»¶ä¸­,å¦æéè¿å¯é çæ¹æ³ä¸è½è¿è¡è¿é¡¹å¤ç,å°å¯¼è´é«æéçã
 
æäºä½¿ç¨
ããå¯ä»¥éå¸¸ç´æ¥å°ä½¿ç¨åºäºNORçéªå­,å¯ä»¥åå¶ä»å­å¨å¨é£æ ·è¿æ¥,å¹¶å¯ä»¥å¨ä¸é¢ç´æ¥è¿è¡ä»£ç ã
ããç±äºéè¦I/Oæ¥å£,NANDè¦å¤æå¾å¤ãåç§NANDå¨ä»¶çå­åæ¹æ³å åå®¶èå¼ã
ããå¨ä½¿ç¨NANDå¨ä»¶æ¶,å¿é¡»ååå¥é©±å¨ç¨åº,æè½ç»§ç»­æ§è¡å¶ä»æä½ãåNANDå¨ä»¶åå¥ä¿¡æ¯éè¦ç¸å½çæå·§,å ä¸ºè®¾è®¡å¸ç»ä¸è½åå
ååå¥,è¿å°±æå³çå¨NANDå¨ä»¶ä¸èªå§è³ç»é½å¿é¡»è¿è¡èææ å°ã
 
è½¯ä»¶æ¯æ
ããå½è®¨è®ºè½¯ä»¶æ¯æçæ¶å,åºè¯¥åºå«åºæ¬çè¯»/å/æ¦æä½åé«ä¸çº§çç¨äºç£çä»¿çåéªå­ç®¡çç®æ³çè½¯ä»¶,åæ¬æ§è½ä¼åã
ããå¨NORå¨ä»¶ä¸è¿è¡ä»£ç ä¸éè¦ä»»ä½çè½¯ä»¶æ¯æ,å¨NANDå¨ä»¶ä¸è¿è¡åæ ·æä½æ¶,éå¸¸éè¦é©±å¨ç¨åº,ä¹å°±æ¯åå­ææ¯é©±å¨ç¨åº(MTD),NANDåNORå¨ä»¶å¨è¿è¡åå¥åæ¦é¤æä½æ¶é½éè¦MTDã
ããä½¿ç¨NORå¨ä»¶æ¶æéè¦çMTDè¦ç¸å¯¹å°ä¸äº,è®¸å¤ååé½æä¾ç¨äºNORå¨ä»¶çæ´é«çº§è½¯ä»¶,è¿å¶ä¸­åæ¬M-SystemçTrueFFSé©±å¨,è¯¥é©±å¨è¢«Wind River SystemãMicrosoftãQNX Software SystemãSymbianåIntelç­ååæéç¨ã
ããé©±å¨è¿ç¨äºå¯¹DiskOnChipäº§åè¿è¡ä»¿çåNANDéªå­çç®¡ç,åæ¬çº éãååå¤çåæèå¹³è¡¡ã
```
# åè
 * http://www.bunniestudios.com/blog/?p=898
 * http://raspberrypi.stackexchange.com/questions/169/how-can-i-extend-the-life-of-my-sd-card
 * http://www.bunniestudios.com/blog/?p=918
# HelloWorld
```cpp
#include <stdio.h>
int * calcArgc(char **argv);
int * calcArgc(char **argv) {
    int *p = (int)argv;
    return p - 1;
}
void printArgc(char **argv) {
    int *argc = calcArgc(argv);
    printf("addr=%p argc=%d  
", argc, *argc);
}
void printArgv(char **argv) {
    int argc = *(calcArgc(argv));
    int i;
    for(i=0; i<argc; ++i) {
        printf("addr=%p value='%s'
", argv+i, *(argv+i));
    }
}
void dump(char ** p) {
    if(p == NULL) {
        return;
    }
    while (*p != NULL) {
        printf("addr=%p value='%s'
", p, *p);
        p++;
    }
}
void printEnv(char **argv) {
    int * argc = calcArgc(argv);
    char ** env = argc + *argc + 2;
    dump(env);
}
int main(int argc, char **argv) {
    printArgc(argv);
    printArgv(argv);
    printEnv(argv);
    return 0;
}
```
```sh
$ gcc helloworld.c
$ export TEST="HelloWorld"
$ ./a.out a b c d e
addr=0xbfc83ac0 argc=6  
#-------------------------------------[ argv ]
addr=0xbfc83ac4 value='./a.out'
addr=0xbfc83ac8 value='a'
addr=0xbfc83acc value='b'
addr=0xbfc83ad0 value='c'
addr=0xbfc83ad4 value='d'
addr=0xbfc83ad8 value='e'
#-------------------------------------[ env ]
addr=0xbfc83ae0 value='STY=666.pts-0.lambda'
addr=0xbfc83b98 value='WINDOWID=23068678'
...
addr=0xbfc83b9c value='COLORFGBG=default;default;0'
addr=0xbfc83ba0 value='TERMINFO=/usr/share/terminfo'
addr=0xbfc83ba4 value='COLORTERM=rxvt-xpm'
addr=0xbfc83ba8 value='OLDPWD=/data/src/c/so'
addr=0xbfc83bac value='vcs_info_msg_0_='
addr=0xbfc83bb0 value='vcs_info_msg_1_='
addr=0xbfc83bb4 value='TEST=HelloWorld'
```
ç¨gdbæ¥ä»ç»è§å¯ä¸ä¸
```sh
$ gcc -g helloworld.c
$ gdb a.out a b c d e
(gdb) b main
(gdb) run
(gdb) frame
#0  main (argc=1, argv=0xbfffe8a4) at helloworld.c:43
43          printArgc(argv);
(gdb) info registers
eax            0x1      1
ecx            0xbfffe8a4       -1073747804
edx            0x8048517        134513943
ebx            0xb7fbf000       -1208225792
esp            0xbfffe7f0       0xbfffe7f0
ebp            0xbfffe808       0xbfffe808
esi            0x0      0
edi            0x0      0
eip            0x8048520        0x8048520 <main+9>
eflags         0x286    [ PF SF IF ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) p &argc
$1 = (int *) 0xbfffe810
(gdb) p &argv
$2 = (char ***) 0xbfffe814
```
æåè§£éä¸åæ,ä¹åå°GovernoråI/O Schedulerä¸æ¯å¾äºè§£
æä»¥æ´çäºä¸äºç¶²è·¯ä¸çè³æçµ¦æ°æåç¥éå¤§æ¦æ¯ä¸åè¨­å®çåºæ¬åè½çºä½
å¦ææä»»ä½è§£éé¯èª¤æè§å¿µä¸æ­£ç¢ºçè©±
æ­¡è¿é«æåè¼©ææä¸¦æä¾ç¸éçç¶é©,çµ¦å¤§å®¶åçºæ¥å¾æ­éçåè
Governor
Linux Kernelæ ¸å¿é è¨­çé»æºç®¡çæ¨¡å¼ä¸­ï¼æåç¨®ä¸åçCPUé »çç®¡çæ¨¡å¼ï¼Androidä¹å»¶çºäºå¤§å¤æ¸çCPUç®¡çæ¨¡å¼ãå¾ä¾è¡çåºä¸å°Androidå°ç¨çCPUç®¡çæ¨¡å¼,èGovernorå°±æ¯ç³»çµ±é è¨­çCPUé »çç®¡çæ¨¡å¼ãä¸é¢æ´çä¸äºå¸¸è¦çGovernor,æ¥å¾æå¨ç¹¼çºå¢ä¿®ç¸éå§å®¹ã
ãondemandã
å¤æ¸çå®æ¹å§æ ¸é è¨­å¼é½é¸æéåï¼æç§ç¨å¼ç³»çµ±çéè¦èª¿æ´cpué »çï¼ä¸ä½¿ç¨æå°cpuæ§å¶ç¶­æå¨æä½é »çï¼
è§¸æ§è¢å¹ææéåç¨å¼ææå¿«éçå°é »çæåå°æé«ï¼ä¸ç¨çæåéè³æä½ï¼æ§è½åçé»æææ®éã
ãpowersaveã
å°cpuæ§å¶ç¶­æå¨æä½é »çã
ãperformanceã
å°cpuæ§å¶ç¶­æå¨æé«é »çã
ãuserspaceã
å´æ ¼ä¾èªªå®ä¸¦ä¸æ¯ä¸åæ¨¡å¼ï¼æ¯åè¨±éå§æ ¸é²ç¨æ§å¶cpué »ççè¨­ç½®ï¼å¤æ¸xdaä¸çé«æé½å»ºè­°ï¼ä¸è¦æ¡ç¨æ­¤ç¨®æ¨¡å¼ã
ãconservativeã
é¡ä¼¼ondemandæ§å¶æ¨¡å¼ï¼ä½æåcpué »ççéåº¦æ¯è¼æ¢ï¼ä¸ç¨çæåécpuçé »çæ¯è¼è¿éï¼æ§è½è¡¨ç¾ç¥ä½ä¸äºï¼çé»æææ¯ondemandå¥½ä¸äºã
ãinteractiveã
ä½¿ç¨ææ©ææç´æ¥å°é »çæåå°æé«ï¼å°ç¨æ¶çæä½åæéåº¦æ¯è¼å¿«ï¼ä¸ä½¿ç¨ææ¢æ¢çéè³æä½é »çã
ãinteractivexã
interactiveçæ¹è¯çï¼æ´çºçé»ã
ãhotplugã
èondemandæ¨¡å¼ç¸å,ä½å¨ä¸ä½¿ç¨ææééå¤é¤çæ ¸å¿ã
ãsmartassã
interactiveçæ¹è¯ççï¼æ´çºçé»ãä¾æä½¿ç¨èæä½ç¿æ£æºè½æä¾ä¸åæ¯è¼ä¸­éå¼çé »çï¼ä¸ç¨çæåéé »çï¼è¢å¹éå±çææç¶­æåºå®é »çã
ãsmartassv2ã
smartassæ¹è¯çã
ãsmoothassã
æ¯smartassæ´ç©æ¥µçèª¿æ´cpuçé »çè®åã
ãsavagedzenã
èsmartassé¡ä¼¼çæ¨¡å¼ï¼å¨çé»ææåæ§è½çå¹³è¡¡æ§æ¯è¼å¥½ä¸äºã
ãminmaxã
é¡ä¼¼conservativeçæ¨¡å¼ï¼çé»æææ¯smartassv2ä½ä¸äºï¼ä½æ§è½è¡¨ç¾å¥½ä¸é»ã
ãscaryã
ä»¥conservativeæ¨¡å¼çºä¸»ï¼ä½ä¹æsmartassæ¨¡å¼çåè½ã
ãlagfreeã
é¡ä¼¼conservativeæ¨¡å¼ï¼é »çæåæ¯è¼ç·©æ¢ï¼ä½¿ç¨èè§¸æ§è¢å¹è¢å¾æç´æ¥æåå°ä¸åé©åçé »çï¼æ¸å°å»¶é²çç¾è±¡ã
ãintellidemandã
æä¾æGPUçä½¿ç¨çæ³èª¿æ´cpué »çï¼èè²»è¼å¤GPUè³æºçæåï¼æè¿éå°cpué »çæåå°æé«ï¼ç¶GPUä½¿ç¨æ¯è¼å°ææèªåéå¶cpuçæé«é »çã
ãLazyLazyã
èOndemandé¡ä¼¼ï¼ä½é »çè®åçéåº¦æ¯è¼æ¢ã
ãondemandqã
èondemandæ¨¡å¼ç¸å,ä½ç¶è¢å¹æ¯ééççæææééå¤é¤ä¸ç¨çæ ¸å¿åªä¿çä¸åæ ¸å¿ã
I/O Scheduler
ç¶ç±ä¸åçè¨­å®ï¼ä¾éå°èª¿æ´ç£ç¢å­å(I/O)æ¨¡å¼
ãnoopã
å¯ä»¥ç®æ¯æåºæ¬ä¸ç°¡åçSchedulerï¼ä¸»è¦æç¨æ¼ä¸äºè¼çºç¹å¥çè»é«èç¡¬é«æ­éæä½çç°å¢ä¸­ï¼
ä¸éäºè»/ç¡¬é«å·²ç¶å·åæèªå·±çI/Oå­åæ©å¶ï¼ä¸å°æ¼ç³»çµ±æ ¸å¿çè¦æ±è¼å°ï¼éæ¨£çScheduleræ¯è¼é©åéç¨å¨åµå¥å¼çç°å¢ç³»çµ±ä¸­ã
ãcfqã
éå°ç¡¬ç¢èç³»çµ±æç¨æéè¦çææI/Oä»»åï¼ååéçµ¦ç¸åçä½åé åº(Queuing)ï¼
éæ¨£çScheduleræé©åç¨æ¼ä¸è¬ä½¿ç¨èæ¡ä¸åé»è¦çæä½ç°å¢ï¼èªå¾Linux Kernel 2.6.18ä»¥å¾
é½ä»¥CFQåçºé è¨­ç I/O schedulerãSonyçå®æ¹æ ¸å¿ä¹æ¯ä»¥cfqçºé è¨­å¼ã
ãdeadlineã
å®æéå°ç£ç¢ä¸­ç¶å¸¸é­å°å­åçä¸åæç¨ç¨å¼ï¼è¨éä¸¦è£½ä½ç¬¦åæå°å»¶é²æéçä½åé åºï¼éæ¨£ççµæå°æ¼è³æåº«ç³»çµ±è½æä¾æ´å çå­åæçã
ãvrã
å·æådeadlineç¸ä¼¼çæä½æåºæ©å¶ï¼æèæé«çå³°å¼è®å¯«éåº¦ï¼ä½æ¯æ§è½æ¯è¼ä¸ç©©å®ï¼ä¹å°±æ¯èªªå¯è½è·åºæé«çåæ¸ï¼ä½æ¯ä¹æåºç¾æä½å¼ã
ãsioã
åºæ¼deadlineï¼ä½ånoopä¸æ¨£ï¼ä¸æå°ioæä½é²è¡æåºï¼æä»¥æènoopé£æ¨£å¿«éçå­åéåº¦ï¼ä½ä¸¦æ²æéå¤åªåioæä½ãå¦æä¸åæ­¡noopå®å¨ä¸åèèª¿åº¦ï¼ä¹å¯ä»¥é¸æéåã
æ ¹æxdaçé«ædroidphileçç¶é©,æ¯è¼æ¨è¦çè¨­å®å¼é åºçºSIO > Noop > Deadline > VR > BFQ > CFQ,ä½å¯¦éçææéæ¯æå çºå¦ç¬¬ä¸æ¹æ ¸å¿,ä¸åçROM,Governorçæ­éç­å ç´ èæå·®å¥,éæ¯è¦ä½ èªå·±å»æ¾åºæé©åççµå
åè¨»:
Kernel Governors, Modules, I/O Schedulers, CPU Tweaks, AIO App Configs
æ¸¬è©¦èªªæ: å¾Linuxç¡¬ç¢æè½èª¿æ ¡åè§I/O Schedulerä»¥åReadahead Cache
ãç§æ®ãCPUèª¿éå¨åI/Oèª¿åº¦è©³è§£ï¼çµæ¼å¨é¨æ¾å°äºï¼
setcpuä¸­çcpuè°èæ¨¡å¼åioè°åº¦æ¨¡å¼è¯¦è§£
å çºå¼ç¨çåèçæç« å¾å¤ä¸å¾éäº,æä»¥åªååºå¹¾åä¸»è¦çç¶²ç«ä¾æº
å¦ææ¨è¦ºå¾æ­¤ç¯æç« å§å®¹æä¾µç¯å°ä½ çæ¬ç,éº»è«åç¥ææç¡å¿«èç
å¦æéç¯æç« å°ä½ ææ¶ç©«å¹«å©çè©±è«è¨å¾æè©åæ¯æå
# åè
 * http://forum.xda-developers.com/showthread.php?t=1558153
[[TOC]]
# åå­ç®¡ç
æä»¬æ¥è§å¯ä¸ä¸linuxçinitè¿ç¨å®éä¸æ¯æä¹ä½¿ç¨èæå°åç©ºé´ç:
|| start-end || perm || offset || major:minor || inode || image ||
 * start-end: èµ·å§VAåç»æ­¢VA
 * é¡µæé: `rwx[s|p]`
   * rwx: å¯è¯»/å¯å/å¯æ§è¡
   * p|s: private æ shared
ååé¡¹é½æ¯è·imageæä»¶ç¸å³ç:
 * offset: æ­¤é¡µé¢æåå«çåå®¹å¨æºæä»¶ä¸­çåç§»é(æºæä»¶å³: image, å®çè·¯å¾è§æåä¸è¡)
 * major:minor: imageæå¨å­å¨è®¾å¤çä¸»è®¾å¤å·åä»è®¾å¤å·(or device mappings, the major and minor numbers refer to the disk partition holding the device special file that was opened by the user, and not the device itself.)
 * inode: imageæä»¶çinodeå·
 * image: imageçæä»¶è·¯å¾
```sh
$ sudo cat /proc/1/maps
08048000-0812d000 r-xp 00000000 08:02 11543323   /usr/lib/systemd/systemd
0812e000-0813c000 r--p 000e5000 08:02 11543323   /usr/lib/systemd/systemd
0813c000-0813d000 rw-p 000f3000 08:02 11543323   /usr/lib/systemd/systemd
09b6c000-09bd8000 rw-p 00000000 00:00 0          [heap]
b73ad000-b747a000 rw-p 00000000 00:00 0 
b747a000-b748f000 r-xp 00000000 08:02 11540729   /usr/lib/libz.so.1.2.7
b748f000-b7490000 r--p 00014000 08:02 11540729   /usr/lib/libz.so.1.2.7
b7490000-b7491000 rw-p 00015000 08:02 11540729   /usr/lib/libz.so.1.2.7
b7491000-b7495000 r-xp 00000000 08:02 11541306   /usr/lib/libattr.so.1.1.0
b7495000-b7496000 r--p 00003000 08:02 11541306   /usr/lib/libattr.so.1.1.0
b7496000-b7497000 rw-p 00004000 08:02 11541306   /usr/lib/libattr.so.1.1.0
b7497000-b7498000 rw-p 00000000 00:00 0 
b7498000-b749b000 r-xp 00000000 08:02 11536561   /usr/lib/libdl-2.17.so
b749b000-b749c000 r--p 00002000 08:02 11536561   /usr/lib/libdl-2.17.so
b749c000-b749d000 rw-p 00003000 08:02 11536561   /usr/lib/libdl-2.17.so
b749d000-b7646000 r-xp 00000000 08:02 11536514   /usr/lib/libc-2.17.so
b7646000-b7648000 r--p 001a8000 08:02 11536514   /usr/lib/libc-2.17.so
b7648000-b7649000 rw-p 001aa000 08:02 11536514   /usr/lib/libc-2.17.so
b7649000-b764c000 rw-p 00000000 00:00 0 
b764c000-b7663000 r-xp 00000000 08:02 11536555   /usr/lib/libpthread-2.17.so
b7663000-b7664000 r--p 00016000 08:02 11536555   /usr/lib/libpthread-2.17.so
b7664000-b7665000 rw-p 00017000 08:02 11536555   /usr/lib/libpthread-2.17.so
b7665000-b7667000 rw-p 00000000 00:00 0 
b7667000-b766e000 r-xp 00000000 08:02 11536517   /usr/lib/librt-2.17.so
b766e000-b766f000 r--p 00006000 08:02 11536517   /usr/lib/librt-2.17.so
b766f000-b7670000 rw-p 00007000 08:02 11536517   /usr/lib/librt-2.17.so
b7670000-b76b9000 r-xp 00000000 08:02 11542568   /usr/lib/libdbus-1.so.3.7.2
b76b9000-b76ba000 r--p 00048000 08:02 11542568   /usr/lib/libdbus-1.so.3.7.2
b76ba000-b76bb000 rw-p 00049000 08:02 11542568   /usr/lib/libdbus-1.so.3.7.2
b76bb000-b76bc000 rw-p 00000000 00:00 0 
b76bc000-b76d2000 r-xp 00000000 08:02 11542915   /usr/lib/libkmod.so.2.2.3
b76d2000-b76d3000 r--p 00015000 08:02 11542915   /usr/lib/libkmod.so.2.2.3
b76d3000-b76d4000 rw-p 00016000 08:02 11542915   /usr/lib/libkmod.so.2.2.3
b76d4000-b76d8000 r-xp 00000000 08:02 11541387   /usr/lib/libcap.so.2.22
b76d8000-b76d9000 rw-p 00003000 08:02 11541387   /usr/lib/libcap.so.2.22
b76d9000-b76e5000 r-xp 00000000 08:02 11540901   /usr/lib/libpam.so.0.83.1
b76e5000-b76e6000 r--p 0000b000 08:02 11540901   /usr/lib/libpam.so.0.83.1
b76e6000-b76e7000 rw-p 0000c000 08:02 11540901   /usr/lib/libpam.so.0.83.1
b76e7000-b76f8000 r-xp 00000000 08:02 11543299   /usr/lib/libudev.so.1.3.3
b76f8000-b76f9000 r--p 00010000 08:02 11543299   /usr/lib/libudev.so.1.3.3
b76f9000-b76fa000 rw-p 00011000 08:02 11543299   /usr/lib/libudev.so.1.3.3
b76fa000-b76fc000 r-xp 00000000 08:02 11543275   /usr/lib/libsystemd-daemon.so.0.0.10
b76fc000-b76fd000 r--p 00001000 08:02 11543275   /usr/lib/libsystemd-daemon.so.0.0.10
b76fd000-b76fe000 rw-p 00002000 08:02 11543275   /usr/lib/libsystemd-daemon.so.0.0.10
b7707000-b7712000 r-xp 00000000 08:02 11536582   /usr/lib/libnss_files-2.17.so
b7712000-b7713000 r--p 0000a000 08:02 11536582   /usr/lib/libnss_files-2.17.so
b7713000-b7714000 rw-p 0000b000 08:02 11536582   /usr/lib/libnss_files-2.17.so
b7714000-b7717000 rw-p 00000000 00:00 0 
b7717000-b7718000 r-xp 00000000 00:00 0          [vdso]
b7718000-b7738000 r-xp 00000000 08:02 11536557   /usr/lib/ld-2.17.so
b7738000-b7739000 r--p 0001f000 08:02 11536557   /usr/lib/ld-2.17.so
b7739000-b773a000 rw-p 00020000 08:02 11536557   /usr/lib/ld-2.17.so
bfb1f000-bfb40000 rw-p 00000000 00:00 0          [stack]
```
pmapå·¥å·å¯ä»¥è¾å©æ¥çè¿ç¨å¨
```sh
$ sudo pmap 1
1:   /sbin/init
08048000    916K r-x-- systemd
0812e000     56K r---- systemd
0813c000      4K rw--- systemd
09b6c000    432K rw---   [ anon ]
b73ad000    820K rw---   [ anon ]
b747a000     84K r-x-- libz.so.1.2.7
b748f000      4K r---- libz.so.1.2.7
b7490000      4K rw--- libz.so.1.2.7
b7491000     16K r-x-- libattr.so.1.1.0
b7495000      4K r---- libattr.so.1.1.0
b7496000      4K rw--- libattr.so.1.1.0
b7497000      4K rw---   [ anon ]
b7498000     12K r-x-- libdl-2.17.so
b749b000      4K r---- libdl-2.17.so
b749c000      4K rw--- libdl-2.17.so
b749d000   1700K r-x-- libc-2.17.so
b7646000      8K r---- libc-2.17.so
b7648000      4K rw--- libc-2.17.so
b7649000     12K rw---   [ anon ]
b764c000     92K r-x-- libpthread-2.17.so
b7663000      4K r---- libpthread-2.17.so
b7664000      4K rw--- libpthread-2.17.so
b7665000      8K rw---   [ anon ]
b7667000     28K r-x-- librt-2.17.so
b766e000      4K r---- librt-2.17.so
b766f000      4K rw--- librt-2.17.so
b7670000    292K r-x-- libdbus-1.so.3.7.2
b76b9000      4K r---- libdbus-1.so.3.7.2
b76ba000      4K rw--- libdbus-1.so.3.7.2
b76bb000      4K rw---   [ anon ]
b76bc000     88K r-x-- libkmod.so.2.2.3
b76d2000      4K r---- libkmod.so.2.2.3
b76d3000      4K rw--- libkmod.so.2.2.3
b76d4000     16K r-x-- libcap.so.2.22
b76d8000      4K rw--- libcap.so.2.22
b76d9000     48K r-x-- libpam.so.0.83.1
b76e5000      4K r---- libpam.so.0.83.1
b76e6000      4K rw--- libpam.so.0.83.1
b76e7000     68K r-x-- libudev.so.1.3.3
b76f8000      4K r---- libudev.so.1.3.3
b76f9000      4K rw--- libudev.so.1.3.3
b76fa000      8K r-x-- libsystemd-daemon.so.0.0.10
b76fc000      4K r---- libsystemd-daemon.so.0.0.10
b76fd000      4K rw--- libsystemd-daemon.so.0.0.10
b7707000     44K r-x-- libnss_files-2.17.so
b7712000      4K r---- libnss_files-2.17.so
b7713000      4K rw--- libnss_files-2.17.so
b7714000     12K rw---   [ anon ]
b7717000      4K r-x--   [ anon ]
b7718000    128K r-x-- ld-2.17.so
b7738000      4K r---- ld-2.17.so
b7739000      4K rw--- ld-2.17.so
bfb1f000    132K rw---   [ stack ]
 total     5140K
```
 1. æ¯ä¸ªå±äº«åºé½æä¸æ¡æè¿°è®°å½:
```
b747a000     84K r-x-- libz.so.1.2.7 # åªè¯»ï¼ ææ§è¡æéï¼æä»¥æ¯.textæ®µ
b748f000      4K r---- libz.so.1.2.7 # åªè¯»ï¼åºè¯¥æ¯.dataæ®µ
b7490000      4K rw--- libz.so.1.2.7 # å¯è¯»åï¼åºè¯¥æ¯.bssæ®µ
```
 2. æ³¨ææ¯æ®µVMçå¤§å°ï¼é½æ¯Pageå¤§å°çæ´æ°å
å¦ææ³è§å¯æ´å¨é¢çä¿¡æ¯:
```sh
$[sudo] pmap -XX 1
 Address Perm   Offset Device    Inode Size  Rss  Pss Shared_Clean Shared_Dirty Private_Clean Private_Dirty Referenced Anonymous AnonHugePages Swap KernelPageSize MMUPageSize Locked                VmFlagsMapping
08048000 r-xp 00000000  08:02 11543323  916  220  220            0            0           220             0        220         0             0    0              4           4      0    rd ex mr mw me dw  systemd
0812e000 r--p 000e5000  08:02 11543323   56    8    8            0            0             4             4          8         4             0    0              4           4      0    rd mr mw me dw ac  systemd
0813c000 rw-p 000f3000  08:02 11543323    4    4    4            0            0             0             4          4         4             0    0              4           4      0 rd wr mr mw me dw ac  systemd
09b6c000 rw-p 00000000  00:00        0  432  284  284            0            0             0           284        272       284             0    0              4           4      0    rd wr mr mw me ac  [heap]
b73ad000 rw-p 00000000  00:00        0  820  416  416            0            0             0           416        256       416             0    0              4           4      0    rd wr mr mw me ac  
b747a000 r-xp 00000000  08:02 11540729   84    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  libz.so.1.2.7
b748f000 r--p 00014000  08:02 11540729    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libz.so.1.2.7
b7490000 rw-p 00015000  08:02 11540729    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libz.so.1.2.7
b7491000 r-xp 00000000  08:02 11541306   16    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  libattr.so.1.1.0
b7495000 r--p 00003000  08:02 11541306    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libattr.so.1.1.0
b7496000 rw-p 00004000  08:02 11541306    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libattr.so.1.1.0
b7497000 rw-p 00000000  00:00        0    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  
b7498000 r-xp 00000000  08:02 11536561   12    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  libdl-2.17.so
b749b000 r--p 00002000  08:02 11536561    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libdl-2.17.so
b749c000 rw-p 00003000  08:02 11536561    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libdl-2.17.so
b749d000 r-xp 00000000  08:02 11536514 1700  220   11          220            0             0             0        220         0             0    0              4           4      0       rd ex mr mw me  libc-2.17.so
b7646000 r--p 001a8000  08:02 11536514    8    8    8            0            0             0             8          8         8             0    0              4           4      0       rd mr mw me ac  libc-2.17.so
b7648000 rw-p 001aa000  08:02 11536514    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libc-2.17.so
b7649000 rw-p 00000000  00:00        0   12   12   12            0            0             0            12          8        12             0    0              4           4      0    rd wr mr mw me ac  
b764c000 r-xp 00000000  08:02 11536555   92   16    0           16            0             0             0         16         0             0    0              4           4      0       rd ex mr mw me  libpthread-2.17.so
b7663000 r--p 00016000  08:02 11536555    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libpthread-2.17.so
b7664000 rw-p 00017000  08:02 11536555    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libpthread-2.17.so
b7665000 rw-p 00000000  00:00        0    8    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  
b7667000 r-xp 00000000  08:02 11536517   28    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  librt-2.17.so
b766e000 r--p 00006000  08:02 11536517    4    4    4            0            0             0             4          0         4             0    0              4           4      0       rd mr mw me ac  librt-2.17.so
b766f000 rw-p 00007000  08:02 11536517    4    4    4            0            0             0             4          0         4             0    0              4           4      0    rd wr mr mw me ac  librt-2.17.so
b7670000 r-xp 00000000  08:02 11542568  292   16    4           16            0             0             0         16         0             0    0              4           4      0       rd ex mr mw me  libdbus-1.so.3.7.2
b76b9000 r--p 00048000  08:02 11542568    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libdbus-1.so.3.7.2
b76ba000 rw-p 00049000  08:02 11542568    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libdbus-1.so.3.7.2
b76bb000 rw-p 00000000  00:00        0    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  
b76bc000 r-xp 00000000  08:02 11542915   88    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  libkmod.so.2.2.3
b76d2000 r--p 00015000  08:02 11542915    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libkmod.so.2.2.3
b76d3000 rw-p 00016000  08:02 11542915    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libkmod.so.2.2.3
b76d4000 r-xp 00000000  08:02 11541387   16    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  libcap.so.2.22
b76d8000 rw-p 00003000  08:02 11541387    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libcap.so.2.22
b76d9000 r-xp 00000000  08:02 11540901   48    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  libpam.so.0.83.1
b76e5000 r--p 0000b000  08:02 11540901    4    4    4            0            0             0             4          0         4             0    0              4           4      0       rd mr mw me ac  libpam.so.0.83.1
b76e6000 rw-p 0000c000  08:02 11540901    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libpam.so.0.83.1
b76e7000 r-xp 00000000  08:02 11543299   68   44   23           40            0             4             0         44         0             0    0              4           4      0       rd ex mr mw me  libudev.so.1.3.3
b76f8000 r--p 00010000  08:02 11543299    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libudev.so.1.3.3
b76f9000 rw-p 00011000  08:02 11543299    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libudev.so.1.3.3
b76fa000 r-xp 00000000  08:02 11543275    8    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  libsystemd-daemon.so.0.0.10
b76fc000 r--p 00001000  08:02 11543275    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libsystemd-daemon.so.0.0.10
b76fd000 rw-p 00002000  08:02 11543275    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libsystemd-daemon.so.0.0.10
b7707000 r-xp 00000000  08:02 11536582   44    0    0            0            0             0             0          0         0             0    0              4           4      0       rd ex mr mw me  libnss_files-2.17.so
b7712000 r--p 0000a000  08:02 11536582    4    4    4            0            0             0             4          4         4             0    0              4           4      0       rd mr mw me ac  libnss_files-2.17.so
b7713000 rw-p 0000b000  08:02 11536582    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd wr mr mw me ac  libnss_files-2.17.so
b7714000 rw-p 00000000  00:00        0   12   12   12            0            0             0            12          8        12             0    0              4           4      0    rd wr mr mw me ac  
b7717000 r-xp 00000000  00:00        0    4    4    0            4            0             0             0          4         0             0    0              4           4      0    rd ex mr mw me de  [vdso]
b7718000 r-xp 00000000  08:02 11536557  128    0    0            0            0             0             0          0         0             0    0              4           4      0    rd ex mr mw me dw  ld-2.17.so
b7738000 r--p 0001f000  08:02 11536557    4    4    4            0            0             0             4          4         4             0    0              4           4      0    rd mr mw me dw ac  ld-2.17.so
b7739000 rw-p 00020000  08:02 11536557    4    4    4            0            0             0             4          4         4             0    0              4           4      0 rd wr mr mw me dw ac  ld-2.17.so
bfb1f000 rw-p 00000000  00:00        0  136   24   24            0            0             0            24         20        24             0    0              4           4      0 rd wr mr mw me gd ac  [stack]
                                       ==== ==== ==== ============ ============ ============= ============= ========== ========= ============= ==== ============== =========== ====== 
                                       5144 1404 1142          296            0           228           880       1208       880             0    0            212         212      0 KB 
```
 * [stack] : æ åºèµ·å§ä½ç½®
 * [vdso] : èæå±äº«å¯¹è±¡
 * [heap] : å åº
ä»ä¸é¢è¿äºä¿¡æ¯ä¸­æä»¬å¤§è´å¯ä»¥çåºç¨åºå¯¹VMAçä½¿ç¨æåµ:
|| 0xC0000000 ||= åæ ¸å°åç©ºé´ =|| åæ ¸ç©ºé´ä¸ç¨æ·ç©ºé´çå°åè¾¹çç±TASK_SIZEå®ä¹
||  ||             || éæºåç§»
||  ||= â æ åº =|| Stackåºå¤§å°ç±RLIMIT_STACKç¡®å®ï¼éå¸¸ä¸º8M
||  || ||  random of mmap offset
||  ||= â Memory Mapping Segment  =|| å¨æåºï¼anonymous æ å°
|| || ||xxx
||  ||= â å åº =|| 
||  ||  || random brk offset ||
|| ||= BSS Segment  =|| `static char * message;`
||  ||= DATA Segement =|| `static char * message="hello";`
||  ||= TEXT Segment =|| æä»¤
# size
å¯ä»¥éè¿sizeå½ä»¤æ¥çELFæä»¶ä¸»è¦æ®µçå¤§å°ã
||= hello.c ||= TEXT=||= DATA=||= BSS=||= DEC=||= HEX=||= FILE=||
```td
```cpp
#include <stdio.h>
int main() {
  return 0;
}
```
```
||1035    || 276||  4||  1315|| 523|| a.out ||
|------------------------------------------
```td
```cpp
#include <stdio.h>
int main() {
    static sM = 1;
    return 0;
}
```
```
|| 1035  || (`+4`)`280`|| 4||  1319||  527|| a.out||
|------------------------------------------
```td
```cpp
#include <stdio.h>
int main() {
    static sM = 1;
    static sX;
    static sY = 0;
    return 0;
}
```
```
|| 1035  || 280|| (`+8`)`12`||  1327||  52f|| a.out||
|------------------------------------------
```td
```cpp
#include <stdio.h>
int gX;
int main() {
    static sM = 1;
    static sX;
    static sY = 0;
    return 0;
}
```
```
|| 1035  || 280|| (`+4`)`16`||  1331||  533|| a.out||
|------------------------------------------
```td
```cpp
#include <stdio.h>
int gX;
int gM = 1;
int main() {
    static sM = 1;
    static sX;
    static sY = 0;
    return 0;
}
```
```
|| 1035  || (`+4`)`284`|| 16||  1335||  537|| a.out||
|------------------------------------------
```td
```cpp
#include <stdio.h>
int gM = 1;
int gX;
int gY = 0;
int main() {
    static sM = 1;
    static sX;
    static sY = 0;
    return 0;
}
```
```
|| 1035  || 284|| (`+4`)`20`||  1339||  53b|| a.out||
 * å·²åå§åç`éæåé`å`å¨å±åé`(åå§å¼ä¸ä¸º0)è¢«ç¼è¯å°`.data`æ®µ
 * æªåå§åç`éæåé`å`å¨å±åé`(åå§å¼ä¸ä¸º0)è¢«ç¼è¯å°`.bss`æ®µ
è¿å¥mainå½æ°åï¼æ çç¶æå¦ä¸:
|| null ||
|| ç¯å¢åé ||
|| null ||
|| åæ° ||
|| argc ||
----
# dup2
```cpp
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
int main (int argc, const char * argv[]) {
    int fd = open("hello.txt", O_RDWR);
    printf("fd=%d
",fd);
    // dup2æç¹éå®åçææï¼putså½æ°çè¾åºå°ä¼éå°hello.txtæä»¶ä¸­
    dup2(fd,1);
    puts("hello world!");
    return 0;
}
```
# åè
 * [Os/SystemCall/fcntl]
[[TOC]]
# exec
execå¯ä»¥å°æå®çå¯æ§è¡image, è£è½½å°å½åè¿ç¨ä¸­. å¸¸å¸¸ä¸forkç»åä½¿ç¨.
[[TOC]]
# fcntl
```cpp
       #include <unistd.h>
       #include <fcntl.h>
       int fcntl(int fildes, int cmd, ...);
```
# ptrace
```cpp
       #include <sys/ptrace.h>
       long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);
```
 * ptraceå¯ä»¥è¿½è¸ªå¹¶æ§å¶æå®è¿ç¨çæ§è¡è¿ç¨
 * ptraceå¯ä»¥æ¥çæèä¿®æ¹traceeè¿ç¨çå¯å­å¨, VMA
 * å¨åå­ä¸­æéé®é¢è¢«å¿½ç¥
ç±äºptraceè¿äºå¼ºå¤§ï¼èªç¶æäººä¼æå®çä¸»æï¼æ¿ptraceå¹²äºå·é¸¡æ¸ççäºæãä¸é¢æä»¬æ¥åæä¸ä¸ã
# Fucking injectsoæ¯å¦ä½å·¥ä½ç?
å¸¸è§çä¸ç§ææ®µå°±æ¯åç®æ è¿ç¨ç©ºé´æ³¨å¥DSO, å¶å®ç¨mmapç³»ç»è°ç¨å¯ä»¥å¹²è¿ä¸ªäºå¿ï¼ä½æ¯è¿æ ·ç®åç²æ´çåå­æ å°ä¹åå¹¶ä¸è½ç«å»å·¥ä½ï¼å ä¸ºDSOä¸­çè¯¸å¤å¯¹è±¡éè¦éæ°è®¡ç®å°åãè¿æ¬æ¥æ¯å¨æé¾æ¥å¨çå·¥ä½ï¼å¯ç¹çäºãæä»¥å±ä»¬è¿æ¯ç¨dlopenå è½½ä¸ä¸ªDSOè¿æ¥æ´å æ¹ä¾¿ä¸äºãå¤§æ¦çæè·¯å¦ä¸:
 * ç¨ptraceç²ä½ç®æ è¿ç¨
 * ä¿å­å½åæ ä¿¡æ¯
 * ä¿å­å½åå¯å­å¨éå
 * ä¼ªé å½æ°è°ç¨çæ å¸§ï¼è¿åå¼ä¸º0
 * ä¿®æ¹å¯å­å¨ï¼åå¤è°ç¨dlopen
   * rip : &dlopen / dlopenå½æ°çå°å
   * rdi : DSOçåç§°, æ³¨æä¸æ¯PATHåï¼æä»¥å¯è½ä¼ç¨LD_LIBARY_PATHæåä½ æ³¨å¥soçè·¯å¾
   * rsi :  DSOæå¼æ¨¡å¼ï¼åçdlopenå½æ°çåååè¯´æ
 * let er rip, waitpid and itâll segfault on returnto 0.
 * æ¢å¤æ ï¼å¯å­å¨éåï¼ç®æ è¿ç¨å¯ä»¥ç»§ç»­è·å¦
ä»ä»¥ä¸è¿ç¨ä¸­å¯ä»¥çåºï¼å¤§æ¦æè·¯å°±æ¯æåç®æ è¿ç¨çæ§è¡ï¼ä¿å­ä¸ä¸æä¿¡æ¯ï¼ä¼ªé dlopenè°ç¨ï¼å®ææ³¨å¥ï¼æ¢å¤ä¸ä¸æï¼è®©ç®æ è¿ç¨ç»§ç»­ã
# Anti ptrace
```cpp
int stayalive ;
void trapcatch (int  ii) {
    stayalive = 1;
}
int main(void) {
...
stayalive = 1;
signal (SIGTRAP, trapcatch ) ;
while ( stayalive ) {
    stayalive = 0;
    kill(getpid(), SIGTRAP ) ;
    do_the_work() ;
}
```
# åè
 * https://github.com/ice799/injectso64
 * http://mips42.altervista.org/ptrace.php

