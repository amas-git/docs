# 通用编程规范

## 命名

有关命名的规则不计其数，常见的就有：

- Camel-Case
- 帕斯卡
- 匈牙利
- 下划线命名法

每个人都在强调命名规范的重要性，却很少提及为什么这么做。甚至有的时候命名规范违背了当初美好的意愿。

有时候规范过于教条，变成了大家都要遵守的愚蠢规定。

> 原则一：传递一致性

我们为事物命名，是想区别于其它的事物。所以只要与其它任何事物不重名就可以了。

每个人对同一事物的看法不同，因此对事物的命名方式也不同。

当大家聚在一起谈论同一事物的时候，麻烦就会产生。我们常常需要花时间统一语言。

编程与之类似，我们常常认为编程是一件个人的事情，其实编程是实实在在的集体活动。就算你写下一行最简单的helloworld, 这个打印函数也是另外一个人实现并为他取名的。更别说编程工作了，每个人都需要与其他人配合来完成一件事情。

假如我们想要把学生的名字录入数据库，并且可以通过网页查询出来。名字，英文叫name, 在数据库中存储在name字段里，服务端同学读到内存中保存到mName变量里，格式化输出成JSON格式保存在student_name字段中，前端同学解析后保存到id="s_name"的div中，客户端同学解析student_name保存在mStudentName里，并且客户端数据库中保存到student_name中...

 - DBA: _name
 - 服务端: sName, name
 - 客户端 mName, NAME
 - ...

如果你不想把这世界搞的更加混乱，你最好把一致性传递下去。



> 原则二：微观一致性优先

遵循命名规范的确可以第一眼看上去很规整，但是规整不等于便于理解和使用。

```
name        -> mName
hello_world -> mHelloWorld
```

命名规范本质上是一种映射，映射增加了理解信息的难度。你的大脑要剥开一层一层映射的壳才能看到想看的，这会消耗脑力，如果两个人看上去是一样的那就是同一个人，我们就应该这么处理信息。

```
# 假如1和2之间有联系，我们记做
1 -> 2

# 增加一层映射
1:a 2:b
1 -> 2 , 1 -> b, a -> 2, a -> b

# 这四种形式都等价于 1 -> 2, 我说a -> b就是1 -> 2, 感受一下你脑子的混乱程度
```

映射是违反微观一致性原则。在宏观上保证命名规范是一定要牺牲微观一致性的。

映射会给查找搜索带来麻烦，

匈牙利命名法发明的时候，我们的编程工具还不是那么强大，现代的IDE可以准确的高亮所有语法要素。如果你不是色盲的话匈牙利命名法那些零其实没什么必要。

还有一个古老的80字符折行的规定，是因为过去的屏幕都太小了。



## IO

如果没有文件，没有socket, 没有IPC, 没有web, 编程会是多么简单的一件事情。

你能干的就是定义变量，然后通过函数f改变这个变量。这就是运算的本质。

狭义的IO包括

- 文件读写
- 网络

```
int n = 1;
int n = db.get('n');
int n = http.get('http://numbers/n');
```

```
int n = store.n();
```





今日充值情况

未审核: 0

已完成: 100单

BTC  10人