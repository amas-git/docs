<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="异步javascript的引擎并不了解时间的概念，它只保证在需要的时候可以执行所需要的代码片段。 事件循环和tick时间循环不断的处理发生的时间，一个循环又叫做一个tick。对于setTimeout(…)这样的函数，工作原理就是设置一个定时器，在到达预订时间后将回调函数放到事件循环中。由于并不能插队，所以智能排队等待着被处理。如果前面的事件比较多，或者比较消耗时间，那么setTimeout可能会不">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript玩闹">
<meta property="og:url" content="http://yoursite.com/2018/03/22/javascript-play/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="异步javascript的引擎并不了解时间的概念，它只保证在需要的时候可以执行所需要的代码片段。 事件循环和tick时间循环不断的处理发生的时间，一个循环又叫做一个tick。对于setTimeout(…)这样的函数，工作原理就是设置一个定时器，在到达预订时间后将回调函数放到事件循环中。由于并不能插队，所以智能排队等待着被处理。如果前面的事件比较多，或者比较消耗时间，那么setTimeout可能会不">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-05-15T03:35:36.226Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript玩闹">
<meta name="twitter:description" content="异步javascript的引擎并不了解时间的概念，它只保证在需要的时候可以执行所需要的代码片段。 事件循环和tick时间循环不断的处理发生的时间，一个循环又叫做一个tick。对于setTimeout(…)这样的函数，工作原理就是设置一个定时器，在到达预订时间后将回调函数放到事件循环中。由于并不能插队，所以智能排队等待着被处理。如果前面的事件比较多，或者比较消耗时间，那么setTimeout可能会不">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>JavaScript玩闹</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss --><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2018/03/27/zsh-ZshParameterExpansion/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/03/19/zsh-zsh-lover/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Post Anterior</span>
      <span id="i-next" class="info" style="display:none;">Post Següent</span>
      <span id="i-top" class="info" style="display:none;">Adalt</span>
      <span id="i-share" class="info" style="display:none;">Compartir Post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2018/03/22/javascript-play/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2018/03/22/javascript-play/&text=JavaScript玩闹"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2018/03/22/javascript-play/&is_video=false&description=JavaScript玩闹"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JavaScript玩闹&body=Check out this article: http://yoursite.com/2018/03/22/javascript-play/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2018/03/22/javascript-play/&name=JavaScript玩闹&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.1.</span> <span class="toc-text">事件循环和tick</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.1.</span> <span class="toc-text">控制转移是callback hell的根本原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">反转控制转移:Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.1.</span> <span class="toc-text">如何用Promise实现超时模式: race + timeoutPromise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.2.</span> <span class="toc-text">被忽略掉的Promise怎么处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.</span> <span class="toc-text">函数: 所有的函数都是对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">6.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">6.1.</span> <span class="toc-text">this指向函数自身? [错误]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">6.2.</span> <span class="toc-text">this指向函数的作用域？ [错误]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.</span> <span class="toc-text">this究竟是个啥？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.1.</span> <span class="toc-text">规则一: 默认绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.2.</span> <span class="toc-text">规则二: 隐式绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.3.</span> <span class="toc-text">规则三: 显示绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.4.</span> <span class="toc-text">规则四: new 绑定, 可以改变this绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">7.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        JavaScript玩闹
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Hexo</span>
      </span>
      
    <div class="postdate">
        <time datetime="2018-03-22T03:11:58.000Z" itemprop="datePublished">2018-03-22</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2><span id="yi-bu">异步</span></h2><p>javascript的引擎并不了解时间的概念，它只保证在需要的时候可以执行所需要的代码片段。</p>
<h3><span id="shi-jian-xun-huan-he-tick">事件循环和tick</span></h3><p>时间循环不断的处理发生的时间，一个循环又叫做一个tick。<br>对于setTimeout(…)这样的函数，工作原理就是设置一个定时器，在到达预订时间后将回调函数放到事件循环中。<br>由于并不能插队，所以智能排队等待着被处理。如果前面的事件比较多，或者比较消耗时间，那么setTimeout可能会不那么精确。</p>
<blockquote>
<p>ES6之前并没有描述应该如何实现事件循环，ES6中对此做了精确的定义。<br>Promise的引入，要求对事件循环能够直接进行精准控制。<br>Promise并不是在event queue中而是被放入了job queue，<br>而诸如setTimeout函数则是放入到了event queue中</p>
</blockquote>
<h2><span id="hui-diao">回调</span></h2><h3><span id="kong-zhi-zhuan-yi-shi-callback-hell-de-gen-ben-yuan-yin">控制转移是callback hell的根本原因</span></h3><ul>
<li>使用回调一个常见的问题是控制转移，回调函数是否被回调，何时回调以及回调多少次都是由第三方来控制的，因此相当于代码控制权部分交给了第三方。</li>
<li>即使回调委托给自己的代码，仍然会有类似问题存在，因此对于回调之后的参数检查是非常必要的，仍然要考虑以下几个问题:<ul>
<li>是否被回调</li>
<li>是否过早或过晚被回调</li>
<li>是否回调了过多的次数</li>
</ul>
</li>
<li>分离回调: 将错误回调和正常回调分开处理， 对于同样一个异步API,你需要指定两个回调函数</li>
<li>Error-First: Node风格的回调函数设计， 回调函数的第一个参数用来保存错误对象，若没有错误发生，这个对像为空</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="fan-zhuan-kong-zhi-zhuan-yi-promise">反转控制转移:Promise</span></h2><p>假如我们能够收回控制权，不就可以避免callback hell了么？</p>
<p>Promise代表将来值，一个Promise对象有三种状态:</p>
<ul>
<li>Pending: 执行中</li>
<li>Fulfilled: 完成</li>
<li>Rejected: 失败</li>
</ul>
<h3><span id="ru-he-yong-promise-shi-xian-chao-shi-mo-shi-race-timeoutpromise">如何用Promise实现超时模式: race + timeoutPromise</span></h3><h3><span id="bei-hu-lue-diao-de-promise-zen-me-chu-li">被忽略掉的Promise怎么处理</span></h3><p>### </p>
<p>一旦Promise对象变成Fulfilled或者Rejected, 那么这个状态就没法再改变了. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 假如执行成功，调用resolve(return-value)</span></span><br><span class="line">        <span class="comment">// 失败调用rejected</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>resolve/reject这俩函数是系统定义好传过来的，作用就是改变Promise对象的状态</li>
</ul>
<h2><span id="prototype">prototype</span></h2><ul>
<li>在Javascript语言中，new命令后面跟的不是类，而是构造函数。</li>
<li>只有函数具有prototype属性</li>
<li>原型链的最终root是Object.prototype</li>
<li>Function.prototype是个不同于一般函数（对象）的函数（对象）</li>
<li>Object.prototype instansof Function.prototype == true</li>
<li>Function.prototype instansof Object.prototype == true</li>
<li>普通函数继承于Function.prototype</li>
<li>Function.prototype继承于Object.prototype, 且Function.prototype.prototype是null</li>
<li>Object是一个构造函数, 是Function的实例，Object.<em>proto</em></li>
<li>先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生。</li>
</ul>
<p>用函数来实现类，js是这么干的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// this指的是新生成的People实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> People(<span class="string">'Jonny'</span>); <span class="comment">// &lt;- new 后面其实是构造函数,</span></span><br></pre></td></tr></table></figure></p>
<p>这么干之后一个新的问题来了，这俩对象如何共享一些属性，比如在java里面我们可以通过static成员来共享，但是目前这个思路不行，不仅没法共享，而且会造成大量的重复资源。<br>因此想到假如给构造函数加一个prototype属性，这个属性用来保存共享的属性和方法貌似就解决了问题.</p>
<h2><span id="han-shu-suo-you-de-han-shu-du-shi-dui-xiang">函数: 所有的函数都是对象</span></h2><h2><span id="this">this</span></h2><h3><span id="this-zhi-xiang-han-shu-zi-shen-cuo-wu">this指向函数自身? [错误]</span></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">    f(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.count); <span class="comment">// 答案: 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为什么是0？ 不是10？</li>
<li>this.count究竟干了什么？</li>
</ul>
<p>现在来稍微修改一下代码,把this换成函数的名字<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    f.count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">    f(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.count); <span class="comment">// 答案: 10</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>看来this不是指向函数自身的，而函数的名字是</li>
</ul>
<p>我们再来一种方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">    f.call(f,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.count); <span class="comment">// 答案: 10</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="this-zhi-xiang-han-shu-de-zuo-yong-yu-cuo-wu">this指向函数的作用域？ [错误]</span></h3><ul>
<li>javascript中尽管作用域有些类似对象，但是它只是一个引擎内部的概念，没有代码可以引用作用域</li>
</ul>
<h3><span id="this-jiu-jing-shi-ge-sha">this究竟是个啥？</span></h3><ul>
<li>this是在运行的时候才绑定到一个<code>上下文对象</code></li>
<li>函数被调用的时候，会创建一个活动记录(或者也可以叫做上下文)</li>
<li>this就是这个上下文的一个属性而已</li>
</ul>
<p>因此this实际上要在运行的时候你才能搞明白它究竟绑定了什么，<br>为此有四条规则。当下面四条规则发生冲突的时候，靠后的规则具有更高的优先级.</p>
<h4><span id="gui-ze-yi-mo-ren-bang-ding">规则一: 默认绑定</span></h4><p>非严格模式下，this可以绑定到全局对象，严格模式下则不行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 严格模式下:</span></span><br></pre></td></tr></table></figure>
<ul>
<li>foo()被调用时，没有任何修饰，所以智能用默认绑定，默认绑定就是在非严格模式下绑定到全局对象,<br>如果严格模式，则this此时只能绑定到undefined</li>
</ul>
<h4><span id="gui-ze-er-yin-shi-bang-ding">规则二: 隐式绑定</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2= &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    o1: o1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o2.o1.foo(); <span class="comment">//1, this绑定到o1上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fb = o2.o1.foo; <span class="comment">// 我们定义一个fb指向o2.o1.foo会发生什么？</span></span><br><span class="line">fb(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">setTimeout(o2.o1.foo, <span class="number">0</span>); <span class="comment">//假如我们把函数作为callback给出去，结果也是undefined, 就如上面的例子一样</span></span><br></pre></td></tr></table></figure>
<h4><span id="gui-ze-san-xian-shi-bang-ding">规则三: 显示绑定</span></h4><p>call和apply,这俩函数可以明确指定绑定对象，这就解决了默认绑定和隐式绑定的诸多问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">foo.call(o1); <span class="comment">// this绑定到o1上，结果是1</span></span><br><span class="line">foo.call(o2); <span class="comment">// this绑定到o2上，结果是2</span></span><br></pre></td></tr></table></figure></p>
<p>硬绑定: 现在我们用显式绑定来解决一下callback导致绑定丢失的问题:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo.call(o1); <span class="comment">// 显式绑定到o1上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(fb,<span class="number">0</span>); <span class="comment">// 答案: 1, 这下不会有不确定的绑定问题了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过这么一折腾，fb就被绑定到o1上了，这么做有些不那么灵活，所以我们稍微修改一下, </span></span><br><span class="line"><span class="comment">// 这件事情的本质是提供一个明确this绑定的包装函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.apply(object);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(bind(foo, o1)); <span class="comment">// 答案: 1</span></span><br><span class="line">setTimeout(bind(foo, o2)); <span class="comment">// 答案: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如此常用的方法已经在ES5中提供了bind方法</span></span><br><span class="line">setTimeout(foo.bind(o1), <span class="number">0</span>);</span><br><span class="line">setTimeout(foo.bind(o2), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>既然可以显示指定绑定的上下文，那我们设计依赖于上下文执行的函数的时候，是不是可以明确指定一下绑定对象来避免这种混淆呢？ 结果我们多了一个参数，而少了一个this, 这恰恰说明this是怎样简化代码的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(o1);</span><br><span class="line">foo(o2);</span><br></pre></td></tr></table></figure></p>
<h4><span id="gui-ze-si-new-bang-ding-ke-yi-gai-bian-this-bang-ding">规则四: new 绑定, 可以改变this绑定</span></h4><p>回想一下java如何new一个object</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>Object()是一个特殊的函数，我们叫做构造函数</li>
<li>在javascript的世界里，并没有所谓的构造函数，所有的函数都可以通过new来修饰调用，因此所谓的构造函数只不过是一个普通的函数，并不属于某个object.</li>
</ul>
<p>通过new来调用函数， 实际上会发生如下的事情:</p>
<ol>
<li>构建一个全新的对象</li>
<li>这个新对象进行prototype链接</li>
<li>新对象绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，那么new调用函数后返回新对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">"A"</span>); <span class="comment">// 普通的函数调用: this在严格模式下理应绑定到undefined上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> foo(<span class="string">"A"</span>); <span class="comment">// new 调用， this被绑定到新创建的foo对象上, new影响了this的绑定行为</span></span><br></pre></td></tr></table></figure>
<p>最后，我们来看看new绑定和显示绑定谁更霸道一些:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fx</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.a != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">fx.prototype.a= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fx_hardbind = fx.bind(o1); <span class="comment">// 显示绑定到o1上了</span></span><br><span class="line">fx_hardbind(<span class="number">111</span>)               <span class="comment">// 因为绑定到o1上， o1.a == 1, 所以尽管传入111, 无法完成赋值，结果仍然是1</span></span><br><span class="line"><span class="keyword">new</span> fx_hardbind(<span class="number">111</span>);          <span class="comment">// 这回new改变了this的绑定，不是绑定到o1了，而是绑定到新创建的对象，a == 0, 所以可以进行赋值， 最终答案是:  111</span></span><br></pre></td></tr></table></figure></p>
<h2><span id="mo-kuai">模块</span></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylibs.js定义并导出方法</span></span><br><span class="line">exports.hello = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模块</span></span><br><span class="line"><span class="keyword">var</span> MyLibs = <span class="built_in">require</span>(<span class="string">'./mylibs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(MyLibs.hello());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取模块</span></span><br></pre></td></tr></table></figure>
<h2><span id="can-kao">参考</span></h2><ul>
<li><a href="http://www.ecma-international.org/ecma-262/6.0/ECMA-262.pdf" target="_blank" rel="noopener">ECMA262/ECMAScript6</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html</a></li>
</ul>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">1.1.</span> <span class="toc-text">事件循环和tick</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.1.</span> <span class="toc-text">控制转移是callback hell的根本原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">反转控制转移:Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.1.</span> <span class="toc-text">如何用Promise实现超时模式: race + timeoutPromise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">3.2.</span> <span class="toc-text">被忽略掉的Promise怎么处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.</span> <span class="toc-text">函数: 所有的函数都是对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">6.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">6.1.</span> <span class="toc-text">this指向函数自身? [错误]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">6.2.</span> <span class="toc-text">this指向函数的作用域？ [错误]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.</span> <span class="toc-text">this究竟是个啥？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.1.</span> <span class="toc-text">规则一: 默认绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.2.</span> <span class="toc-text">规则二: 隐式绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.3.</span> <span class="toc-text">规则三: 显示绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.4.</span> <span class="toc-text">规则四: new 绑定, 可以改变this绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">7.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2018/03/22/javascript-play/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2018/03/22/javascript-play/&text=JavaScript玩闹"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2018/03/22/javascript-play/&is_video=false&description=JavaScript玩闹"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JavaScript玩闹&body=Check out this article: http://yoursite.com/2018/03/22/javascript-play/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2018/03/22/javascript-play/&title=JavaScript玩闹"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2018/03/22/javascript-play/&name=JavaScript玩闹&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menú</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Compartir</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Cap amunt</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 amas
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Inici</a></li>
         
          <li><a href="/about/">Qui som</a></li>
         
          <li><a href="/archives/">Articles</a></li>
         
          <li><a href="/projects_url">Projectes</a></li>
        
      </ul>
    </nav>
  </div>
</footer><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


